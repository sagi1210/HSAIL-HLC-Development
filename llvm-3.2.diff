Only in llvm-3.2.src/: build
diff -ur /home/amd/Prakash/llvm-3.2.org/CMakeLists.txt llvm-3.2.src/CMakeLists.txt
--- /home/amd/Prakash/llvm-3.2.org/CMakeLists.txt	2012-09-28 23:05:20.000000000 +0530
+++ llvm-3.2.src/CMakeLists.txt	2014-09-03 10:29:31.999243296 +0530
@@ -13,6 +13,14 @@
 set(LLVM_VERSION_MAJOR 3)
 set(LLVM_VERSION_MINOR 2)
 
+set(LLVM_REQUIRES_EH ON)
+set(LLVM_REQUIRES_RTTI ON)
+add_definitions(-DANDROID)
+
+include_directories(/home/amd/Prakash/Git/HSAIL-Tools-private/libHSAIL)
+include_directories(/home/amd/Prakash/Git/HSAIL-Tools-private/libHSAIL/libBRIGDwarf)
+include_directories(/home/amd/Prakash/Git/HSAIL-Tools-private/libHSAIL/libHSAIL/generated)
+
 set(PACKAGE_VERSION "${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}svn")
 
 option(LLVM_USE_FOLDERS "Enable solution folders in Visual Studio. Disable for Express versions." ON)
@@ -74,22 +82,13 @@
 set(LLVM_LIBDIR_SUFFIX "" CACHE STRING "Define suffix of library directory name (32/64)" )
 
 set(LLVM_ALL_TARGETS
-  ARM
-  CellSPU
-  CppBackend
-  Hexagon
-  Mips
-  MBlaze
-  MSP430
-  NVPTX
-  PowerPC
-  Sparc
+  HSAIL
   X86
-  XCore
   )
 
+
 # List of targets with JIT support:
-set(LLVM_TARGETS_WITH_JIT X86 PowerPC ARM Mips)
+set(LLVM_TARGETS_WITH_JIT X86)
 
 if( MSVC )
   set(LLVM_TARGETS_TO_BUILD X86
@@ -381,6 +380,8 @@
    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -include llvm/Support/Solaris.h")
 endif( ${CMAKE_SYSTEM_NAME} MATCHES SunOS )
 
+SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
+
 include(AddLLVM)
 include(TableGen)
 
diff -ur /home/amd/Prakash/llvm-3.2.org/include/llvm/ADT/Triple.h llvm-3.2.src/include/llvm/ADT/Triple.h
--- /home/amd/Prakash/llvm-3.2.org/include/llvm/ADT/Triple.h	2012-11-16 02:54:48.000000000 +0530
+++ llvm-3.2.src/include/llvm/ADT/Triple.h	2014-09-03 10:36:37.063251162 +0530
@@ -66,6 +66,8 @@
     nvptx64, // NVPTX: 64-bit
     le32,    // le32: generic little-endian 32-bit CPU (PNaCl / Emscripten)
     amdil,   // amdil: amd IL
+    hsail,   // AMD HSAIL Target
+    hsail_64,// AMD HSAIL_64 Target 
     spir,    // SPIR: standard portable IR for OpenCL 32-bit version
     spir64   // SPIR: standard portable IR for OpenCL 64-bit version
   };
Only in llvm-3.2.src/include/llvm: AMDResolveLinker.h
Only in llvm-3.2.src/include/llvm/Analysis: AMDKernelSymbols.h
diff -ur /home/amd/Prakash/llvm-3.2.org/include/llvm/CodeGen/AsmPrinter.h llvm-3.2.src/include/llvm/CodeGen/AsmPrinter.h
--- /home/amd/Prakash/llvm-3.2.org/include/llvm/CodeGen/AsmPrinter.h	2012-10-08 22:08:25.000000000 +0530
+++ llvm-3.2.src/include/llvm/CodeGen/AsmPrinter.h	2014-08-29 18:00:39.527749619 +0530
@@ -106,7 +106,6 @@
     /// If VerboseAsm is set, a pointer to the loop info for this
     /// function.
     MachineLoopInfo *LI;
-
     /// DD - If the target supports dwarf debug info, this pointer is non-null.
     DwarfDebug *DD;
 
@@ -227,7 +226,9 @@
     /// EmitBasicBlockStart - This method prints the label for the specified
     /// MachineBasicBlock, an alignment (if present) and a comment describing
     /// it if appropriate.
-    void EmitBasicBlockStart(const MachineBasicBlock *MBB) const;
+    // BRIG LOWERING: we have to turn it to virtual and override to maintain 
+    // BasicBlock entry label map.. and it IS NOT CONST anymore
+    virtual void EmitBasicBlockStart(const MachineBasicBlock *MBB);
 
     /// EmitGlobalConstant - Print a general LLVM constant to the .s file.
     void EmitGlobalConstant(const Constant *CV, unsigned AddrSpace = 0);
diff -ur /home/amd/Prakash/llvm-3.2.org/include/llvm/CodeGen/MachineFunction.h llvm-3.2.src/include/llvm/CodeGen/MachineFunction.h
--- /home/amd/Prakash/llvm-3.2.org/include/llvm/CodeGen/MachineFunction.h	2012-09-17 12:29:23.000000000 +0530
+++ llvm-3.2.src/include/llvm/CodeGen/MachineFunction.h	2014-08-29 21:09:42.075959524 +0530
@@ -425,6 +425,7 @@
   /// getPICBaseSymbol - Return a function-local symbol to represent the PIC
   /// base.
   MCSymbol *getPICBaseSymbol() const;
+
 };
 
 //===--------------------------------------------------------------------===//
diff -ur /home/amd/Prakash/llvm-3.2.org/include/llvm/CodeGen/SelectionDAG.h llvm-3.2.src/include/llvm/CodeGen/SelectionDAG.h
--- /home/amd/Prakash/llvm-3.2.org/include/llvm/CodeGen/SelectionDAG.h	2012-09-27 15:44:43.000000000 +0530
+++ llvm-3.2.src/include/llvm/CodeGen/SelectionDAG.h	2014-08-18 16:53:13.000000000 +0530
@@ -511,6 +511,11 @@
   /// integer type VT, by either zero-extending or truncating it.
   SDValue getZExtOrTrunc(SDValue Op, DebugLoc DL, EVT VT);
 
+  /// getBoolExtOrTrunc - Convert Op, which must be of integer type, to the
+  /// integer type VT, by using an extension appropriate for the target's
+  /// BooleanContent or truncating it.
+  SDValue getBoolExtOrTrunc(SDValue Op, DebugLoc SL, EVT VT);
+
   /// getZeroExtendInReg - Return the expression required to zero extend the Op
   /// value assuming it was the smaller SrcTy value.
   SDValue getZeroExtendInReg(SDValue Op, DebugLoc DL, EVT SrcTy);
@@ -620,6 +625,19 @@
     return getNode(ISD::SETCC, DL, VT, LHS, RHS, getCondCode(Cond));
   }
 
+  // getSelect - Helper function to make it easier to build Select's if you just
+  // have operands and don't want to check for vector.
+  SDValue getSelect(DebugLoc DL, EVT VT, SDValue Cond,
+      SDValue LHS, SDValue RHS) {
+    assert(LHS.getValueType() == RHS.getValueType() &&
+        "Cannot use select on differing types");
+    assert(VT.isVector() == LHS.getValueType().isVector() &&
+        "Cannot mix vectors and scalars");
+    return getNode(Cond.getValueType().isVector() ? ISD::VSELECT : ISD::SELECT,
+        DL, VT, Cond, LHS, RHS);
+  }
+
+
   /// getSelectCC - Helper function to make it easier to build SelectCC's if you
   /// just have an ISD::CondCode instead of an SDValue.
   ///
diff -ur /home/amd/Prakash/llvm-3.2.org/include/llvm/DebugInfo.h llvm-3.2.src/include/llvm/DebugInfo.h
--- /home/amd/Prakash/llvm-3.2.org/include/llvm/DebugInfo.h	2012-10-09 13:43:15.000000000 +0530
+++ llvm-3.2.src/include/llvm/DebugInfo.h	2014-08-18 16:57:22.000000000 +0530
@@ -349,6 +349,17 @@
     /// return base type size.
     uint64_t getOriginalTypeSize() const;
 
+    // Index 10 onwards are used for ObjC debug info, but in our
+    // world, we are not interested in ObjC. For lack of a better
+    // "DIPointerType", we will repurpose index 10 to store the
+    // "points-to" address space. Ideally this new field should be
+    // introduced upstream in LLVM trunk.
+
+    /// \brief Return the points-to address space for a pointer type.
+    unsigned getAddressSpace() const {
+      return getUnsignedField(10);
+    }
+
     /// getObjCProperty - Return property node, if this ivar is 
     /// associated with one.
     MDNode *getObjCProperty() const;
diff -ur /home/amd/Prakash/llvm-3.2.org/include/llvm/InitializePasses.h llvm-3.2.src/include/llvm/InitializePasses.h
--- /home/amd/Prakash/llvm-3.2.org/include/llvm/InitializePasses.h	2012-11-03 03:18:17.000000000 +0530
+++ llvm-3.2.src/include/llvm/InitializePasses.h	2014-08-19 12:32:09.000000000 +0530
@@ -208,6 +208,7 @@
 void initializePrintDbgInfoPass(PassRegistry&);
 void initializePrintFunctionPassPass(PassRegistry&);
 void initializePrintModulePassPass(PassRegistry&);
+void initializePrintBasicBlockPassPass(PassRegistry&);
 void initializeProcessImplicitDefsPass(PassRegistry&);
 void initializeProfileEstimatorPassPass(PassRegistry&);
 void initializeProfileInfoAnalysisGroup(PassRegistry&);
@@ -232,6 +233,8 @@
 void initializeSimpleInlinerPass(PassRegistry&);
 void initializeRegisterCoalescerPass(PassRegistry&);
 void initializeSimplifyLibCallsPass(PassRegistry&);
+void initializeKernelSymbolsAnalysisGroup(PassRegistry&);
+void initializeAMDKernelSymbolsPass(PassRegistry&);
 void initializeSingleLoopExtractorPass(PassRegistry&);
 void initializeSinkingPass(PassRegistry&);
 void initializeSlotIndexesPass(PassRegistry&);
@@ -265,6 +268,10 @@
 void initializeLoopVectorizePass(PassRegistry&);
 void initializeBBVectorizePass(PassRegistry&);
 void initializeMachineFunctionPrinterPassPass(PassRegistry&);
+
+void initializeHSAILDAGToDAGISelPass(PassRegistry&);
+void initializeAMDSymbolLinkagePass(PassRegistry&);
+void initializeAMDInlineAllPass(PassRegistry&);
 }
 
 #endif
diff -ur /home/amd/Prakash/llvm-3.2.org/include/llvm/Linker.h llvm-3.2.src/include/llvm/Linker.h
--- /home/amd/Prakash/llvm-3.2.org/include/llvm/Linker.h	2012-03-26 12:28:25.000000000 +0530
+++ llvm-3.2.src/include/llvm/Linker.h	2014-08-30 10:24:36.300842153 +0530
@@ -14,9 +14,12 @@
 #ifndef LLVM_LINKER_H
 #define LLVM_LINKER_H
 
+#include "llvm/ValueSymbolTable.h"
 #include <memory>
 #include <string>
 #include <vector>
+#include <map>
+#include "llvm/ADT/StringRef.h"
 
 namespace llvm {
   namespace sys { class Path; }
@@ -250,8 +253,8 @@
     bool LinkInModule(
       Module* Src,              ///< Module linked into \p Dest
       std::string* ErrorMsg = 0 /// Error/diagnostic string
-    ) { 
-      return LinkModules(Composite, Src, Linker::DestroySource, ErrorMsg ); 
+    ) {
+      return LinkModules(Composite, Src, Linker::DestroySource, ErrorMsg);
     }
 
     /// This is the heart of the linker. This method will take unconditional
@@ -265,6 +268,11 @@
     /// error.
     /// @returns True if an error occurs, false otherwise.
     /// @brief Generically link two modules together.
+
+    static bool LinkModules(Module* Dest, Module* Src, unsigned Mode,
+                            std::map<const Value*, bool>* ReferenceMap,
+                            std::string* ErrorMsg);
+
     static bool LinkModules(Module* Dest, Module* Src, unsigned Mode,
                             std::string* ErrorMsg);
 
Only in llvm-3.2.src/include/llvm/MC: MCELFStreamer.h
diff -ur /home/amd/Prakash/llvm-3.2.org/include/llvm/Operator.h llvm-3.2.src/include/llvm/Operator.h
--- /home/amd/Prakash/llvm-3.2.org/include/llvm/Operator.h	2012-10-25 00:47:42.000000000 +0530
+++ llvm-3.2.src/include/llvm/Operator.h	2014-07-21 15:59:42.000000000 +0530
@@ -16,7 +16,9 @@
 #define LLVM_OPERATOR_H
 
 #include "llvm/Constants.h"
+#include "llvm/DataLayout.h"
 #include "llvm/DerivedTypes.h"
+#include "llvm/Support/GetElementPtrTypeIterator.h"
 #include "llvm/Instruction.h"
 #include "llvm/Type.h"
 
@@ -307,6 +309,75 @@
     }
     return true;
   }
+
+  /// \brief Accumulate the constant address offset of this GEP if possible.
+  ///
+  /// This routine accepts an APInt into which it will accumulate the constant
+  /// offset of this GEP if the GEP is in fact constant. If the GEP is not
+  /// all-constant, it returns false and the value of the offset APInt is
+  /// undefined (it is *not* preserved!). The APInt passed into this routine
+  /// must be at exactly as wide as the IntPtr type for the address space of the
+  /// base GEP pointer.
+  bool accumulateConstantOffset(const DataLayout &DL, APInt &Offset) const {
+    assert(Offset.getBitWidth() ==
+           DL.getPointerSizeInBits(getPointerAddressSpace()) &&
+           "The offset must have exactly as many bits as our pointer.");
+
+    for (gep_type_iterator GTI = gep_type_begin(this), GTE = gep_type_end(this);
+         GTI != GTE; ++GTI) {
+      ConstantInt *OpC = dyn_cast<ConstantInt>(GTI.getOperand());
+      if (!OpC)
+        return false;
+      if (OpC->isZero())
+        continue;
+
+      // Handle a struct index, which adds its field offset to the pointer.
+      if (StructType *STy = dyn_cast<StructType>(*GTI)) {
+        unsigned ElementIdx = OpC->getZExtValue();
+        const StructLayout *SL = DL.getStructLayout(STy);
+        Offset += APInt(Offset.getBitWidth(),
+                        SL->getElementOffset(ElementIdx));
+        continue;
+      }
+
+      // For array or vector indices, scale the index by the size of the type.
+      APInt Index = OpC->getValue().sextOrTrunc(Offset.getBitWidth());
+      Offset += Index * APInt(Offset.getBitWidth(),
+                              DL.getTypeAllocSize(GTI.getIndexedType()));
+    }
+    return true;
+  }
+
+};
+
+class PtrToIntOperator
+    : public ConcreteOperator<Operator, Instruction::PtrToInt> {
+  friend class PtrToInt;
+  friend class ConstantExpr;
+
+public:
+  Value *getPointerOperand() {
+    return getOperand(0);
+  }
+  const Value *getPointerOperand() const {
+    return getOperand(0);
+  }
+  static unsigned getPointerOperandIndex() {
+    return 0U;                      // get index for modifying correct operand
+  }
+
+  /// getPointerOperandType - Method to return the pointer operand as a
+  /// PointerType.
+  Type *getPointerOperandType() const {
+    return getPointerOperand()->getType();
+  }
+
+  /// getPointerAddressSpace - Method to return the address space of the
+  /// pointer operand.
+  unsigned getPointerAddressSpace() const {
+    return cast<PointerType>(getPointerOperandType())->getAddressSpace();
+  }
+
 };
 
 } // End llvm namespace
diff -ur /home/amd/Prakash/llvm-3.2.org/include/llvm/Support/Dwarf.h llvm-3.2.src/include/llvm/Support/Dwarf.h
--- /home/amd/Prakash/llvm-3.2.org/include/llvm/Support/Dwarf.h	2012-03-30 03:05:05.000000000 +0530
+++ llvm-3.2.src/include/llvm/Support/Dwarf.h	2014-08-18 17:23:07.000000000 +0530
@@ -132,6 +132,7 @@
   DW_TAG_GNU_formal_parameter_pack = 0x4108,
   DW_TAG_lo_user = 0x4080,
   DW_TAG_APPLE_property = 0x4200,
+  DW_TAG_HSA_argument_scope = 0x8000,
   DW_TAG_hi_user = 0xffff,
 
   // Children flag
@@ -255,6 +256,11 @@
   DW_AT_GNU_vector = 0x2107,
   DW_AT_GNU_template_name = 0x2110,
   DW_AT_MIPS_assumed_size = 0x2011,
+  DW_AT_HSA_is_kernel = 0x3000,
+  DW_AT_HSA_is_outParam = 0x3001,
+  DW_AT_HSA_workitemid_offset = 0x3002,
+  DW_AT_HSA_isa_memory_region = 0x3003,
+  DW_AT_HSA_brig_offset = 0x3004,
   DW_AT_lo_user = 0x2000,
   DW_AT_hi_user = 0x3fff,
 
@@ -272,6 +278,8 @@
   DW_AT_APPLE_property_attribute = 0x3feb,
   DW_AT_APPLE_objc_complete_type = 0x3fec,
   DW_AT_APPLE_property = 0x3fed,
+  DW_AT_AMDIL_address_space = 0x3ff1,
+  DW_AT_AMDIL_resource = 0x3ff2,
 
   // Attribute form encodings
   DW_FORM_addr = 0x01,
@@ -530,6 +538,7 @@
   DW_LANG_Python = 0x0014,
   DW_LANG_lo_user = 0x8000,
   DW_LANG_Mips_Assembler = 0x8001,
+  DW_LANG_HSA_Assembly = 0x9000,
   DW_LANG_hi_user = 0xffff,
 
   // Identifier case codes
diff -ur /home/amd/Prakash/llvm-3.2.org/include/llvm/Support/ELF.h llvm-3.2.src/include/llvm/Support/ELF.h
--- /home/amd/Prakash/llvm-3.2.org/include/llvm/Support/ELF.h	2012-11-20 09:27:32.000000000 +0530
+++ llvm-3.2.src/include/llvm/Support/ELF.h	2014-08-18 16:53:56.000000000 +0530
@@ -287,6 +287,8 @@
   EM_VIDEOCORE5    = 198, // Broadcom VideoCore V processor
   EM_78KOR         = 199, // Renesas 78KOR family
   EM_56800EX       = 200, // Freescale 56800EX Digital Signal Controller (DSC)
+  EM_HSAIL     = 128,  // HSAIL 32bit
+  EM_HSAIL_64  = 129,  // HSAIL 64bit
   EM_MBLAZE        = 47787 // Xilinx MicroBlaze
 };
 
diff -ur /home/amd/Prakash/llvm-3.2.org/include/llvm/TableGen/Record.h llvm-3.2.src/include/llvm/TableGen/Record.h
--- /home/amd/Prakash/llvm-3.2.org/include/llvm/TableGen/Record.h	2012-10-12 05:00:49.000000000 +0530
+++ llvm-3.2.src/include/llvm/TableGen/Record.h	2014-07-21 17:49:44.000000000 +0530
@@ -991,7 +991,7 @@
 ///
 class BinOpInit : public OpInit {
 public:
-  enum BinaryOp { SHL, SRA, SRL, STRCONCAT, CONCAT, EQ };
+  enum BinaryOp { ADD, SHL, SRA, SRL, STRCONCAT, CONCAT, EQ };
 private:
   BinaryOp Opc;
   Init *LHS, *RHS;
diff -ur /home/amd/Prakash/llvm-3.2.org/include/llvm/Target/TargetInstrInfo.h llvm-3.2.src/include/llvm/Target/TargetInstrInfo.h
--- /home/amd/Prakash/llvm-3.2.org/include/llvm/Target/TargetInstrInfo.h	2012-10-10 11:13:09.000000000 +0530
+++ llvm-3.2.src/include/llvm/Target/TargetInstrInfo.h	2014-09-03 10:28:53.071242575 +0530
@@ -621,6 +621,15 @@
     return false;
   }
 
+  /// Schedule this instruction based entirely on it's Sethi-Ullman number,
+  /// without raising or lowering it's priority based on use or def numbers.
+  /// What this really says is that the instruction has some effect on execution
+  /// that is not modeled in the DAG. (For instance, a multi-thread execution 
+  /// barrier.) 
+  virtual bool shouldScheduleWithNormalPriority(SDNode* instruction) const {
+    return false;
+  }
+
   /// ReverseBranchCondition - Reverses the branch condition of the specified
   /// condition list, returning false on success and true if it cannot be
   /// reversed.
diff -ur /home/amd/Prakash/llvm-3.2.org/include/llvm/Target/TargetLowering.h llvm-3.2.src/include/llvm/Target/TargetLowering.h
--- /home/amd/Prakash/llvm-3.2.org/include/llvm/Target/TargetLowering.h	2012-11-05 08:29:23.000000000 +0530
+++ llvm-3.2.src/include/llvm/Target/TargetLowering.h	2014-08-18 16:58:45.000000000 +0530
@@ -192,7 +192,7 @@
   /// the condition operand of SELECT and BRCOND nodes.  In the case of
   /// BRCOND the argument passed is MVT::Other since there are no other
   /// operands to get a type hint from.
-  virtual EVT getSetCCResultType(EVT VT) const;
+  virtual EVT getSetCCResultType(LLVMContext &Context, EVT VT) const;
 
   /// getCmpLibcallReturnType - Return the ValueType for comparison
   /// libcalls. Comparions libcalls include floating point comparion calls,
diff -ur /home/amd/Prakash/llvm-3.2.org/include/llvm/Transforms/IPO.h llvm-3.2.src/include/llvm/Transforms/IPO.h
--- /home/amd/Prakash/llvm-3.2.org/include/llvm/Transforms/IPO.h	2012-10-27 00:17:48.000000000 +0530
+++ llvm-3.2.src/include/llvm/Transforms/IPO.h	2014-08-18 16:57:56.000000000 +0530
@@ -16,6 +16,9 @@
 #define LLVM_TRANSFORMS_IPO_H
 
 #include <vector>
+#include <set>
+#include <string>
+
 
 namespace llvm {
 
@@ -194,6 +197,16 @@
 /// manager.
 ModulePass *createBarrierNoopPass();
 
+//===----------------------------------------------------------------------===//
+/// createAMDInlineAllPass - Return a new pass object that inlines all
+/// functions. And if isWhole is true (whole program mode), it will also
+/// remove all non-kernel functions.
+///
+Pass *createAMDInlineAllPass(bool isWhole=false);
+ModulePass *createAMDSymbolLinkagePass(bool isWhole=false,
+                                       std::set<std::string> *reqFuns = NULL);
+
+
 } // End llvm namespace
 
 #endif
Only in llvm-3.2.src/lib/Analysis/IPA: AMDKernelSymbols.cpp
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/Analysis/IPA/CMakeLists.txt llvm-3.2.src/lib/Analysis/IPA/CMakeLists.txt
--- /home/amd/Prakash/llvm-3.2.org/lib/Analysis/IPA/CMakeLists.txt	2012-06-24 19:02:01.000000000 +0530
+++ llvm-3.2.src/lib/Analysis/IPA/CMakeLists.txt	2014-08-19 12:30:41.000000000 +0530
@@ -4,6 +4,7 @@
   FindUsedTypes.cpp
   GlobalsModRef.cpp
   IPA.cpp
+  AMDKernelSymbols.cpp 
   )
 
 add_dependencies(LLVMipa intrinsics_gen)
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/AsmPrinter/AsmPrinter.cpp llvm-3.2.src/lib/CodeGen/AsmPrinter/AsmPrinter.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/AsmPrinter/AsmPrinter.cpp	2012-11-01 14:44:31.000000000 +0530
+++ llvm-3.2.src/lib/CodeGen/AsmPrinter/AsmPrinter.cpp	2014-08-29 22:29:50.456048508 +0530
@@ -187,9 +187,6 @@
     OutStreamer.AddBlankLine();
   }
 
-  if (MAI->doesSupportDebugInformation())
-    DD = new DwarfDebug(this, &M);
-
   switch (MAI->getExceptionHandlingType()) {
   case ExceptionHandling::None:
     return false;
@@ -935,6 +932,9 @@
     if (const MCSection *S = MAI->getNonexecutableStackSection(OutContext))
       OutStreamer.SwitchSection(S);
 
+  // LLVM Bug 9761. Nothing should be emitted after EmitEndOfAsmFile()
+  OutStreamer.Finish();
+
   // Allow the target to emit any magic that it wants at the end of the file,
   // after everything else has gone out.
   EmitEndOfAsmFile(M);
@@ -942,7 +942,6 @@
   delete Mang; Mang = 0;
   MMI = 0;
 
-  OutStreamer.Finish();
   return false;
 }
 
@@ -2070,7 +2069,7 @@
 /// EmitBasicBlockStart - This method prints the label for the specified
 /// MachineBasicBlock, an alignment (if present) and a comment describing
 /// it if appropriate.
-void AsmPrinter::EmitBasicBlockStart(const MachineBasicBlock *MBB) const {
+void AsmPrinter::EmitBasicBlockStart(const MachineBasicBlock *MBB) {
   // Emit an alignment directive for this block, if needed.
   if (unsigned Align = MBB->getAlignment())
     EmitAlignment(Align);
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp llvm-3.2.src/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp	2012-10-08 22:08:25.000000000 +0530
+++ llvm-3.2.src/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp	2014-08-30 10:27:02.556844860 +0530
@@ -28,11 +28,16 @@
 #include "llvm/Target/TargetRegisterInfo.h"
 #include "llvm/ADT/APFloat.h"
 #include "llvm/Support/ErrorHandling.h"
+#include "llvm/Module.h"
+#include "llvm/Function.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineModuleInfo.h"
 
 using namespace llvm;
 
+
 /// CompileUnit - Compile unit constructor.
-CompileUnit::CompileUnit(unsigned I, unsigned L, DIE *D, AsmPrinter *A,
+CompileUnit::CompileUnit(unsigned I, unsigned L, DIE *D, AsmPrinter *A, 
                          DwarfDebug *DW)
   : ID(I), Language(L), CUDie(D), Asm(A), DD(DW), IndexTyDie(0) {
   DIEIntegerOne = new (DIEValueAllocator) DIEInteger(1);
@@ -53,10 +58,6 @@
 
 /// addFlag - Add a flag that is true.
 void CompileUnit::addFlag(DIE *Die, unsigned Attribute) {
-  if (!DD->useDarwinGDBCompat())
-    Die->addValue(Attribute, dwarf::DW_FORM_flag_present,
-                  DIEIntegerOne);
-  else
     addUInt(Die, Attribute, dwarf::DW_FORM_flag, 1);
 }
 
@@ -736,12 +737,17 @@
     addString(&Buffer, dwarf::DW_AT_name, Name);
 
   // Add size if non-zero (derived types might be zero-sized.)
-  if (Size && Tag != dwarf::DW_TAG_pointer_type)
+  // HSA Debugger is expecting DW_AT_byte_size for pointer type
+  if (Size && 
+      Tag != dwarf::DW_TAG_pointer_type)
     addUInt(&Buffer, dwarf::DW_AT_byte_size, 0, Size);
 
   // Add source line info if available and TyDesc is not a forward declaration.
   if (!DTy.isForwardDecl())
     addSourceLine(&Buffer, DTy);
+
+  // Add the address space as an attribute
+  addUInt(&Buffer, dwarf::DW_AT_address_class, dwarf::DW_FORM_data4, DTy.getAddressSpace());
 }
 
 /// constructTypeDIE - Construct type DIE from DICompositeType.
@@ -1199,6 +1205,7 @@
     addUInt(Block, 0, dwarf::DW_FORM_data1, dwarf::DW_OP_addr);
     addLabel(Block, 0, dwarf::DW_FORM_udata,
              Asm->Mang->getSymbol(GV.getGlobal()));
+
     // Do not create specification DIE if context is either compile unit
     // or a subprogram.
     if (GVContext && GV.isDefinition() && !GVContext.isCompileUnit() &&
@@ -1344,7 +1351,7 @@
     addString(VariableDie, dwarf::DW_AT_name, Name);
     addSourceLine(VariableDie, DV->getVariable());
     addType(VariableDie, DV->getType());
-  }
+      }
 
   if (DV->isArtificial())
     addFlag(VariableDie, dwarf::DW_AT_artificial);
@@ -1361,6 +1368,7 @@
     addLabel(VariableDie, dwarf::DW_AT_location,
                          dwarf::DW_FORM_data4,
                          Asm->GetTempSymbol("debug_loc", Offset));
+
     DV->setDIE(VariableDie);
     return VariableDie;
   }
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h llvm-3.2.src/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h
--- /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h	2012-09-11 05:04:03.000000000 +0530
+++ llvm-3.2.src/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h	2014-08-29 23:30:56.144116345 +0530
@@ -20,6 +20,9 @@
 #include "llvm/ADT/StringMap.h"
 #include "llvm/ADT/OwningPtr.h"
 
+// HSA need some functions to be redefined in BRIGDwarfCompileUnit class
+#define VIRTUAL_D virtual
+
 namespace llvm {
 
 class DwarfDebug;
@@ -81,7 +84,8 @@
 
 public:
   CompileUnit(unsigned I, unsigned L, DIE *D, AsmPrinter *A, DwarfDebug *DW);
-  ~CompileUnit();
+
+  VIRTUAL_D ~CompileUnit();
 
   // Accessors.
   unsigned getID()                  const { return ID; }
@@ -189,18 +193,17 @@
 
   /// addString - Add a string attribute data and value.
   ///
-  void addString(DIE *Die, unsigned Attribute, const StringRef Str);
+  VIRTUAL_D void addString(DIE *Die, unsigned Attribute, const StringRef Str);
 
-  /// addLabel - Add a Dwarf label attribute data and value.
+  /// addLabel - Add a Dwarf label attribute data and value
   ///
-  void addLabel(DIE *Die, unsigned Attribute, unsigned Form,
+  VIRTUAL_D void addLabel(DIE *Die, unsigned Attribute, unsigned Form,
                 const MCSymbol *Label);
 
   /// addDelta - Add a label delta attribute data and value.
   ///
-  void addDelta(DIE *Die, unsigned Attribute, unsigned Form,
+  VIRTUAL_D void addDelta(DIE *Die, unsigned Attribute, unsigned Form,
                 const MCSymbol *Hi, const MCSymbol *Lo);
-
   /// addDIEEntry - Add a DIE attribute data and value.
   ///
   void addDIEEntry(DIE *Die, unsigned Attribute, unsigned Form, DIE *Entry);
@@ -256,10 +259,9 @@
   ///
   void addBlockByrefAddress(DbgVariable *&DV, DIE *Die, unsigned Attribute,
                             const MachineLocation &Location);
-
   /// addVariableAddress - Add DW_AT_location attribute for a 
   /// DbgVariable based on provided MachineLocation.
-  void addVariableAddress(DbgVariable *&DV, DIE *Die, MachineLocation Location);
+  VIRTUAL_D void addVariableAddress(DbgVariable *&DV, DIE *Die, MachineLocation Location);
 
   /// addToContextOwner - Add Die into the list of its context owner's children.
   void addToContextOwner(DIE *Die, DIDescriptor Context);
@@ -292,7 +294,7 @@
   DIEEntry *createDIEEntry(DIE *Entry);
 
   /// createGlobalVariableDIE - create global variable DIE.
-  void createGlobalVariableDIE(const MDNode *N);
+  VIRTUAL_D void createGlobalVariableDIE(const MDNode *N);
 
   void addPubTypes(DISubprogram SP);
 
@@ -327,11 +329,11 @@
 
   /// createMemberDIE - Create new member DIE.
   DIE *createMemberDIE(DIDerivedType DT);
+protected:
+  // make DIEValueAllocator protected - to access it from BRIGDwarfCompileUnit.
+  BumpPtrAllocator DIEValueAllocator;
 
 private:
-
-  // DIEValueAllocator - All DIEValues are allocated through this allocator.
-  BumpPtrAllocator DIEValueAllocator;
   DIEInteger *DIEIntegerOne;
 };
 
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/AsmPrinter/DwarfDebug.cpp llvm-3.2.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/AsmPrinter/DwarfDebug.cpp	2012-11-07 10:49:04.000000000 +0530
+++ llvm-3.2.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp	2014-08-29 23:09:24.304092439 +0530
@@ -44,6 +44,7 @@
 #include "llvm/Support/FormattedStream.h"
 #include "llvm/Support/Timer.h"
 #include "llvm/Support/Path.h"
+
 using namespace llvm;
 
 static cl::opt<bool> DisableDebugInfoPrinting("disable-debug-info-print",
@@ -173,11 +174,6 @@
       hasDwarfAccelTables = false;
   } else
     hasDwarfAccelTables = DwarfAccelTables == Enable ? true : false;
-
-  {
-    NamedRegionTimer T(DbgTimerName, DWARFGroupName, TimePassesIsEnabled);
-    beginModule(M);
-  }
 }
 DwarfDebug::~DwarfDebug() {
 }
@@ -509,7 +505,7 @@
   if (LScopes.isCurrentFunctionScope(Scope))
     for (unsigned i = 0, N = CurrentFnArguments.size(); i < N; ++i)
       if (DbgVariable *ArgDV = CurrentFnArguments[i])
-        if (DIE *Arg = 
+        if (DIE *Arg =
             TheCU->constructVariableDIE(ArgDV, Scope->isAbstractScope())) {
           Children.push_back(Arg);
           if (ArgDV->isObjectPointer()) ObjectPointer = Arg;
@@ -518,7 +514,7 @@
   // Collect lexical scope children first.
   const SmallVector<DbgVariable *, 8> &Variables = ScopeVariables.lookup(Scope);
   for (unsigned i = 0, N = Variables.size(); i < N; ++i)
-    if (DIE *Variable = 
+    if (DIE *Variable =
         TheCU->constructVariableDIE(Variables[i], Scope->isAbstractScope())) {
       Children.push_back(Variable);
       if (Variables[i]->isObjectPointer()) ObjectPointer = Variable;
@@ -548,7 +544,7 @@
       return NULL;
     ScopeDIE = constructLexicalScopeDIE(TheCU, Scope);
   }
-  
+
   if (!ScopeDIE) return NULL;
 
   // Add children
@@ -607,6 +603,7 @@
   unsigned ID = GetOrCreateSourceID(FN, CompilationDir);
 
   DIE *Die = new DIE(dwarf::DW_TAG_compile_unit);
+
   CompileUnit *NewCU = new CompileUnit(ID, DIUnit.getLanguage(), Die,
                                        Asm, this);
   NewCU->addString(Die, dwarf::DW_AT_producer, DIUnit.getProducer());
@@ -746,6 +743,9 @@
 /// content. Create global DIEs and emit initial debug info sections.
 /// This is invoked by the target AsmPrinter.
 void DwarfDebug::beginModule(Module *M) {
+  // for HSA moved here from constructor
+  NamedRegionTimer T(DbgTimerName, DWARFGroupName,
+                     TimePassesIsEnabled);
   if (DisableDebugInfoPrinting)
     return;
 
@@ -1103,7 +1103,7 @@
         SLabel = FunctionEndSym;
       else {
         const MachineInstr *End = HI[1];
-        DEBUG(dbgs() << "DotDebugLoc Pair:\n" 
+        DEBUG(dbgs() << "DotDebugLoc Pair:\n"
               << "\t" << *Begin << "\t" << *End << "\n");
         if (End->isDebugValue())
           SLabel = getLabelBeforeInsn(End);
@@ -1115,6 +1115,7 @@
         }
       }
 
+
       // The value is valid until the next DBG_VALUE or clobber.
       DotDebugLocEntries.push_back(getDebugLocEntry(Asm, FLabel, SLabel,
                                                     Begin));
@@ -1134,6 +1135,7 @@
   }
 }
 
+
 /// getLabelBeforeInsn - Return Label preceding the instruction.
 const MCSymbol *DwarfDebug::getLabelBeforeInsn(const MachineInstr *MI) {
   MCSymbol *Label = LabelsBeforeInsn.lookup(MI);
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/AsmPrinter/DwarfDebug.h llvm-3.2.src/lib/CodeGen/AsmPrinter/DwarfDebug.h
--- /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/AsmPrinter/DwarfDebug.h	2012-10-31 19:15:49.000000000 +0530
+++ llvm-3.2.src/lib/CodeGen/AsmPrinter/DwarfDebug.h	2014-08-29 23:44:22.080131260 +0530
@@ -191,6 +191,8 @@
 };
 
 class DwarfDebug {
+// HSA requires relaxed abstraction
+protected:
   /// Asm - Target of Dwarf emission.
   AsmPrinter *Asm;
 
@@ -454,15 +456,18 @@
   /// beginning of or ending of a scope.
   void identifyScopeMarkers();
 
+protected:
   /// addCurrentFnArgument - If Var is an current function argument that add
-  /// it in CurrentFnArguments list.
+  /// it in CurrentFnArguments list. 
   bool addCurrentFnArgument(const MachineFunction *MF,
                             DbgVariable *Var, LexicalScope *Scope);
 
   /// collectVariableInfo - Populate LexicalScope entries with variables' info.
   void collectVariableInfo(const MachineFunction *,
                            SmallPtrSet<const MDNode *, 16> &ProcessedVars);
-  
+
+private:
+
   /// collectVariableInfoFromMMITable - Collect variable information from
   /// side table maintained by MMI.
   void collectVariableInfoFromMMITable(const MachineFunction * MF,
@@ -488,9 +493,14 @@
   //===--------------------------------------------------------------------===//
   // Main entry points.
   //
+protected:
+  // allow constructor call from either AsmPrinter or children
+  // AsmPrinter must call beginModule() after just after instantiating DwarfDebug
+  friend class AsmPrinter;
   DwarfDebug(AsmPrinter *A, Module *M);
-  ~DwarfDebug();
 
+public:
+  virtual ~DwarfDebug();
   /// collectInfoFromNamedMDNodes - Collect debug info from named mdnodes such
   /// as llvm.dbg.enum and llvm.dbg.ty
   void collectInfoFromNamedMDNodes(Module *M);
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/DAGCombiner.cpp llvm-3.2.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/DAGCombiner.cpp	2012-11-26 22:31:12.000000000 +0530
+++ llvm-3.2.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp	2014-08-02 12:04:59.000000000 +0530
@@ -330,6 +330,13 @@
       if (!LegalTypes) return true;
       return TLI.isTypeLegal(VT);
     }
+
+    /// getSetCCResultType - Convenience wrapper around
+    /// TargetLowering::getSetCCResultType
+    EVT getSetCCResultType(EVT VT) const {
+      return TLI.getSetCCResultType(*DAG.getContext(), VT);
+    }
+
   };
 }
 
@@ -4125,7 +4132,7 @@
     return N2;
 
   // Determine if the condition we're dealing with is constant
-  SDValue SCC = SimplifySetCC(TLI.getSetCCResultType(N0.getValueType()),
+  SDValue SCC = SimplifySetCC(getSetCCResultType(N0.getValueType()),
                               N0, N1, CC, N->getDebugLoc(), false);
   if (SCC.getNode()) AddToWorkList(SCC.getNode());
 
@@ -4406,7 +4413,7 @@
       // On some architectures (such as SSE/NEON/etc) the SETCC result type is
       // of the same size as the compared operands. Only optimize sext(setcc())
       // if this is the case.
-      EVT SVT = TLI.getSetCCResultType(N0VT);
+      EVT SVT = getSetCCResultType(N0VT);
 
       // We know that the # elements of the results is the same as the
       // # elements of the compare (and the # elements of the compare result
@@ -4444,14 +4451,20 @@
                        NegOne, DAG.getConstant(0, VT),
                        cast<CondCodeSDNode>(N0.getOperand(2))->get(), true);
     if (SCC.getNode()) return SCC;
-    if (!LegalOperations ||
-        TLI.isOperationLegal(ISD::SETCC, TLI.getSetCCResultType(VT)))
-      return DAG.getNode(ISD::SELECT, N->getDebugLoc(), VT,
-                         DAG.getSetCC(N->getDebugLoc(),
-                                      TLI.getSetCCResultType(VT),
-                                      N0.getOperand(0), N0.getOperand(1),
-                                 cast<CondCodeSDNode>(N0.getOperand(2))->get()),
-                         NegOne, DAG.getConstant(0, VT));
+    if (!VT.isVector()) {
+      EVT SetCCVT = getSetCCResultType(N0.getOperand(0).getValueType());
+      if (!LegalOperations || TLI.isOperationLegal(ISD::SETCC, SetCCVT)) {
+        DebugLoc DL = N->getDebugLoc();
+        const CondCodeSDNode *CC = cast<CondCodeSDNode>(N0.getOperand(2));
+        SDValue SetCC = DAG.getSetCC(N->getDebugLoc(), SetCCVT,
+                                     N0.getOperand(0), N0.getOperand(1),
+                                     CC->get());
+        EVT SelectVT = getSetCCResultType(VT);
+        return DAG.getSelect(DL, VT,
+                             DAG.getSExtOrTrunc(SetCC, DL, SelectVT),
+                             NegOne, DAG.getConstant(0, VT));
+      }
+    }
   }
 
   // fold (sext x) -> (zext x) if the sign bit is known zero.
@@ -6644,7 +6657,7 @@
             cast<ConstantSDNode>(Op1)->getAPIntValue()==AndConst.logBase2()) {
           SDValue SetCC =
             DAG.getSetCC(N->getDebugLoc(),
-                         TLI.getSetCCResultType(Op0.getValueType()),
+                         getSetCCResultType(Op0.getValueType()),
                          Op0, DAG.getConstant(0, Op0.getValueType()),
                          ISD::SETNE);
 
@@ -6708,7 +6721,7 @@
 
       EVT SetCCVT = N1.getValueType();
       if (LegalTypes)
-        SetCCVT = TLI.getSetCCResultType(SetCCVT);
+        SetCCVT = getSetCCResultType(SetCCVT);
       SDValue SetCC = DAG.getSetCC(TheXor->getDebugLoc(),
                                    SetCCVT,
                                    Op0, Op1,
@@ -6739,7 +6752,7 @@
   // MachineBasicBlock CFG, which is awkward.
 
   // Use SimplifySetCC to simplify SETCC's.
-  SDValue Simp = SimplifySetCC(TLI.getSetCCResultType(CondLHS.getValueType()),
+  SDValue Simp = SimplifySetCC(getSetCCResultType(CondLHS.getValueType()),
                                CondLHS, CondRHS, CC->get(), N->getDebugLoc(),
                                false);
   if (Simp.getNode()) AddToWorkList(Simp.getNode());
@@ -9257,7 +9270,7 @@
   ConstantSDNode *N3C = dyn_cast<ConstantSDNode>(N3.getNode());
 
   // Determine if the condition we're dealing with is constant
-  SDValue SCC = SimplifySetCC(TLI.getSetCCResultType(N0.getValueType()),
+  SDValue SCC = SimplifySetCC(getSetCCResultType(N0.getValueType()),
                               N0, N1, CC, DL, false);
   if (SCC.getNode()) AddToWorkList(SCC.getNode());
   ConstantSDNode *SCCC = dyn_cast_or_null<ConstantSDNode>(SCC.getNode());
@@ -9323,7 +9336,7 @@
         SDValue One = DAG.getIntPtrConstant(EltSize);
 
         SDValue Cond = DAG.getSetCC(DL,
-                                    TLI.getSetCCResultType(N0.getValueType()),
+                                    getSetCCResultType(N0.getValueType()),
                                     N0, N1, CC);
         AddToWorkList(Cond.getNode());
         SDValue CstOffset = DAG.getNode(ISD::SELECT, DL, Zero.getValueType(),
@@ -9426,11 +9439,11 @@
     // NOTE: Don't create a SETCC if it's not legal on this target.
     if (!LegalOperations ||
         TLI.isOperationLegal(ISD::SETCC,
-          LegalTypes ? TLI.getSetCCResultType(N0.getValueType()) : MVT::i1)) {
+          LegalTypes ? getSetCCResultType(N0.getValueType()) : MVT::i1)) {
       SDValue Temp, SCC;
       // cast from setcc result type to select result type
       if (LegalTypes) {
-        SCC  = DAG.getSetCC(DL, TLI.getSetCCResultType(N0.getValueType()),
+        SCC  = DAG.getSetCC(DL, getSetCCResultType(N0.getValueType()),
                             N0, N1, CC);
         if (N2.getValueType().bitsLT(SCC.getValueType()))
           Temp = DAG.getZeroExtendInReg(SCC, N2.getDebugLoc(),
@@ -9463,8 +9476,8 @@
   if (0 && N3C && N3C->isNullValue() && N2C && (N2C->getAPIntValue() == 1ULL)) {
     EVT XType = N0.getValueType();
     if (!LegalOperations ||
-        TLI.isOperationLegal(ISD::SETCC, TLI.getSetCCResultType(XType))) {
-      SDValue Res = DAG.getSetCC(DL, TLI.getSetCCResultType(XType), N0, N1, CC);
+        TLI.isOperationLegal(ISD::SETCC, getSetCCResultType(XType))) {
+      SDValue Res = DAG.getSetCC(DL, getSetCCResultType(XType), N0, N1, CC);
       if (Res.getValueType() != VT)
         Res = DAG.getNode(ISD::ZERO_EXTEND, DL, VT, Res);
       return Res;
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp llvm-3.2.src/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp	2012-10-24 22:55:11.000000000 +0530
+++ llvm-3.2.src/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp	2014-08-18 16:28:17.000000000 +0530
@@ -57,6 +57,10 @@
   /// LegalizedNodes - The set of nodes which have already been legalized.
   SmallPtrSet<SDNode *, 16> LegalizedNodes;
 
+  EVT getSetCCResultType(EVT VT) const {
+    return TLI.getSetCCResultType(*DAG.getContext(), VT);
+  }
+
   // Libcall insertion helpers.
 
 public:
@@ -603,7 +607,7 @@
                          false, false, 0);
   // Load the updated vector.
   return DAG.getLoad(VT, dl, Ch, StackPtr,
-                     MachinePointerInfo::getFixedStack(SPFI), false, false, 
+                     MachinePointerInfo::getFixedStack(SPFI), false, false,
                      false, 0);
 }
 
@@ -1538,7 +1542,7 @@
     }
   }
   // Now get the sign bit proper, by seeing whether the value is negative.
-  SignBit = DAG.getSetCC(dl, TLI.getSetCCResultType(SignBit.getValueType()),
+  SignBit = DAG.getSetCC(dl, getSetCCResultType(SignBit.getValueType()),
                          SignBit, DAG.getConstant(0, SignBit.getValueType()),
                          ISD::SETLT);
   // Get the absolute value of the result.
@@ -1599,17 +1603,22 @@
     // Nothing to do.
     break;
   case TargetLowering::Expand: {
+    ISD::CondCode InvCC = ISD::getSetCCSwappedOperands(CCCode);
+    if (TLI.isCondCodeLegal(InvCC, OpVT)) {
+      std::swap(LHS, RHS);
+      CC = DAG.getCondCode(InvCC);
+      return;
+    }
     ISD::CondCode CC1 = ISD::SETCC_INVALID, CC2 = ISD::SETCC_INVALID;
-    ISD::CondCode InvCC = ISD::SETCC_INVALID;
     unsigned Opc = 0;
     switch (CCCode) {
     default: llvm_unreachable("Don't know how to expand this condition!");
-    case ISD::SETO: 
+    case ISD::SETO:
         assert(TLI.getCondCodeAction(ISD::SETOEQ, OpVT)
             == TargetLowering::Legal
             && "If SETO is expanded, SETOEQ must be legal!");
         CC1 = ISD::SETOEQ; CC2 = ISD::SETOEQ; Opc = ISD::AND; break;
-    case ISD::SETUO:  
+    case ISD::SETUO:
         assert(TLI.getCondCodeAction(ISD::SETUNE, OpVT)
             == TargetLowering::Legal
             && "If SETUO is expanded, SETUNE must be legal!");
@@ -1619,7 +1628,7 @@
     case ISD::SETOGE:
     case ISD::SETOLT:
     case ISD::SETOLE:
-    case ISD::SETONE: 
+    case ISD::SETONE:
     case ISD::SETUEQ: 
     case ISD::SETUNE: 
     case ISD::SETUGT: 
@@ -1642,16 +1651,9 @@
     case ISD::SETLT:
     case ISD::SETNE:
     case ISD::SETEQ:
-      InvCC = ISD::getSetCCSwappedOperands(CCCode);
-      if (TLI.getCondCodeAction(InvCC, OpVT) == TargetLowering::Expand) {
-        // We only support using the inverted operation and not a
-        // different manner of supporting expanding these cases.
-        llvm_unreachable("Don't know how to expand this condition!");
-      }
-      LHS = DAG.getSetCC(dl, VT, RHS, LHS, InvCC);
-      RHS = SDValue();
-      CC = SDValue();
-      return;
+      // We only support using the inverted operation, which is computed above
+      // and not a different manner of supporting expanding these cases.
+      llvm_unreachable("Don't know how to expand this condition!");
     }
     
     SDValue SetCC1, SetCC2;
@@ -2207,7 +2209,7 @@
       // select.  We happen to get lucky and machinesink does the right
       // thing most of the time.  This would be a good candidate for a
       //pseudo-op, or, even better, for whole-function isel.
-      SDValue SignBitTest = DAG.getSetCC(dl, TLI.getSetCCResultType(MVT::i64),
+      SDValue SignBitTest = DAG.getSetCC(dl, getSetCCResultType(MVT::i64),
         Op0, DAG.getConstant(0, MVT::i64), ISD::SETLT);
       return DAG.getNode(ISD::SELECT, dl, MVT::f32, SignBitTest, Slow, Fast);
     }
@@ -2220,10 +2222,10 @@
          DAG.getConstant(UINT64_C(0x800), MVT::i64));
     SDValue And2 = DAG.getNode(ISD::AND, dl, MVT::i64, Op0,
          DAG.getConstant(UINT64_C(0x7ff), MVT::i64));
-    SDValue Ne = DAG.getSetCC(dl, TLI.getSetCCResultType(MVT::i64),
+    SDValue Ne = DAG.getSetCC(dl, getSetCCResultType(MVT::i64),
                    And2, DAG.getConstant(UINT64_C(0), MVT::i64), ISD::SETNE);
     SDValue Sel = DAG.getNode(ISD::SELECT, dl, MVT::i64, Ne, Or, Op0);
-    SDValue Ge = DAG.getSetCC(dl, TLI.getSetCCResultType(MVT::i64),
+    SDValue Ge = DAG.getSetCC(dl, getSetCCResultType(MVT::i64),
                    Op0, DAG.getConstant(UINT64_C(0x0020000000000000), MVT::i64),
                    ISD::SETUGE);
     SDValue Sel2 = DAG.getNode(ISD::SELECT, dl, MVT::i64, Ge, Sel, Op0);
@@ -2245,7 +2247,7 @@
 
   SDValue Tmp1 = DAG.getNode(ISD::SINT_TO_FP, dl, DestVT, Op0);
 
-  SDValue SignSet = DAG.getSetCC(dl, TLI.getSetCCResultType(Op0.getValueType()),
+  SDValue SignSet = DAG.getSetCC(dl, getSetCCResultType(Op0.getValueType()),
                                  Op0, DAG.getConstant(0, Op0.getValueType()),
                                  ISD::SETLT);
   SDValue Zero = DAG.getIntPtrConstant(0), Four = DAG.getIntPtrConstant(4);
@@ -2805,7 +2807,7 @@
     APInt x = APInt::getSignBit(NVT.getSizeInBits());
     (void)apf.convertFromAPInt(x, false, APFloat::rmNearestTiesToEven);
     Tmp1 = DAG.getConstantFP(apf, VT);
-    Tmp2 = DAG.getSetCC(dl, TLI.getSetCCResultType(VT),
+    Tmp2 = DAG.getSetCC(dl, getSetCCResultType(VT),
                         Node->getOperand(0),
                         Tmp1, ISD::SETLT);
     True = DAG.getNode(ISD::FP_TO_SINT, dl, NVT, Node->getOperand(0));
@@ -3023,7 +3025,7 @@
     EVT VT = Node->getValueType(0);
     Tmp1 = Node->getOperand(0);
     Tmp2 = DAG.getConstantFP(0.0, VT);
-    Tmp2 = DAG.getSetCC(dl, TLI.getSetCCResultType(Tmp1.getValueType()),
+    Tmp2 = DAG.getSetCC(dl, getSetCCResultType(Tmp1.getValueType()),
                         Tmp1, Tmp2, ISD::SETUGT);
     Tmp3 = DAG.getNode(ISD::FNEG, dl, VT, Tmp1);
     Tmp1 = DAG.getNode(ISD::SELECT, dl, VT, Tmp2, Tmp1, Tmp3);
@@ -3383,10 +3385,10 @@
       Tmp1 = DAG.getConstant(VT.getSizeInBits() - 1,
                              TLI.getShiftAmountTy(BottomHalf.getValueType()));
       Tmp1 = DAG.getNode(ISD::SRA, dl, VT, BottomHalf, Tmp1);
-      TopHalf = DAG.getSetCC(dl, TLI.getSetCCResultType(VT), TopHalf, Tmp1,
+      TopHalf = DAG.getSetCC(dl, getSetCCResultType(VT), TopHalf, Tmp1,
                              ISD::SETNE);
     } else {
-      TopHalf = DAG.getSetCC(dl, TLI.getSetCCResultType(VT), TopHalf,
+      TopHalf = DAG.getSetCC(dl, getSetCCResultType(VT), TopHalf,
                              DAG.getConstant(0, VT), ISD::SETNE);
     }
     Results.push_back(BottomHalf);
@@ -3498,7 +3500,7 @@
     Tmp4 = Node->getOperand(3);   // False
     SDValue CC = Node->getOperand(4);
 
-    LegalizeSetCCCondCode(TLI.getSetCCResultType(Tmp1.getValueType()),
+    LegalizeSetCCCondCode(getSetCCResultType(Tmp1.getValueType()),
                           Tmp1, Tmp2, CC, dl);
 
     assert(!Tmp2.getNode() && "Can't legalize SELECT_CC with legal condition!");
@@ -3515,7 +3517,7 @@
     Tmp3 = Node->getOperand(3);              // RHS
     Tmp4 = Node->getOperand(1);              // CC
 
-    LegalizeSetCCCondCode(TLI.getSetCCResultType(Tmp2.getValueType()),
+    LegalizeSetCCCondCode(getSetCCResultType(Tmp2.getValueType()),
                           Tmp2, Tmp3, Tmp4, dl);
 
     assert(!Tmp3.getNode() && "Can't legalize BR_CC with legal condition!");
@@ -3597,7 +3599,7 @@
     Tmp1 = DAG.getNode(Node->getOpcode(), dl, NVT, Tmp1);
     if (Node->getOpcode() == ISD::CTTZ) {
       // FIXME: This should set a bit in the zero extended value instead.
-      Tmp2 = DAG.getSetCC(dl, TLI.getSetCCResultType(NVT),
+      Tmp2 = DAG.getSetCC(dl, getSetCCResultType(NVT),
                           Tmp1, DAG.getConstant(NVT.getSizeInBits(), NVT),
                           ISD::SETEQ);
       Tmp1 = DAG.getNode(ISD::SELECT, dl, NVT, Tmp2,
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp llvm-3.2.src/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp	2012-10-11 12:52:01.000000000 +0530
+++ llvm-3.2.src/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp	2014-08-02 14:43:37.000000000 +0530
@@ -683,10 +683,10 @@
   NewRHS = DAG.getConstant(0, RetVT);
   CCCode = TLI.getCmpLibcallCC(LC1);
   if (LC2 != RTLIB::UNKNOWN_LIBCALL) {
-    SDValue Tmp = DAG.getNode(ISD::SETCC, dl, TLI.getSetCCResultType(RetVT),
+    SDValue Tmp = DAG.getNode(ISD::SETCC, dl, getSetCCResultType(RetVT),
                                 NewLHS, NewRHS, DAG.getCondCode(CCCode));
     NewLHS = MakeLibCall(LC2, RetVT, Ops, 2, false/*sign irrelevant*/, dl);
-    NewLHS = DAG.getNode(ISD::SETCC, dl, TLI.getSetCCResultType(RetVT), NewLHS,
+    NewLHS = DAG.getNode(ISD::SETCC, dl, getSetCCResultType(RetVT), NewLHS,
                          NewRHS, DAG.getCondCode(TLI.getCmpLibcallCC(LC2)));
     NewLHS = DAG.getNode(ISD::OR, dl, Tmp.getValueType(), Tmp, NewLHS);
     NewRHS = SDValue();
@@ -1304,14 +1304,14 @@
   //         FCMPU crN, lo1, lo2
   // The following can be improved, but not that much.
   SDValue Tmp1, Tmp2, Tmp3;
-  Tmp1 = DAG.getSetCC(dl, TLI.getSetCCResultType(LHSHi.getValueType()),
+  Tmp1 = DAG.getSetCC(dl, getSetCCResultType(LHSHi.getValueType()),
                       LHSHi, RHSHi, ISD::SETOEQ);
-  Tmp2 = DAG.getSetCC(dl, TLI.getSetCCResultType(LHSLo.getValueType()),
+  Tmp2 = DAG.getSetCC(dl, getSetCCResultType(LHSLo.getValueType()),
                       LHSLo, RHSLo, CCCode);
   Tmp3 = DAG.getNode(ISD::AND, dl, Tmp1.getValueType(), Tmp1, Tmp2);
-  Tmp1 = DAG.getSetCC(dl, TLI.getSetCCResultType(LHSHi.getValueType()),
+  Tmp1 = DAG.getSetCC(dl, getSetCCResultType(LHSHi.getValueType()),
                       LHSHi, RHSHi, ISD::SETUNE);
-  Tmp2 = DAG.getSetCC(dl, TLI.getSetCCResultType(LHSHi.getValueType()),
+  Tmp2 = DAG.getSetCC(dl, getSetCCResultType(LHSHi.getValueType()),
                       LHSHi, RHSHi, CCCode);
   Tmp1 = DAG.getNode(ISD::AND, dl, Tmp1.getValueType(), Tmp1, Tmp2);
   NewLHS = DAG.getNode(ISD::OR, dl, Tmp1.getValueType(), Tmp1, Tmp3);
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp llvm-3.2.src/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp	2012-10-24 22:55:11.000000000 +0530
+++ llvm-3.2.src/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp	2014-08-02 14:45:04.000000000 +0530
@@ -492,7 +492,7 @@
   EVT OpTy = N->getOperand(1).getValueType();
 
   // Promote all the way up to the canonical SetCC type.
-  Mask = PromoteTargetBoolean(Mask, TLI.getSetCCResultType(OpTy));
+  Mask = PromoteTargetBoolean(Mask, getSetCCResultType(OpTy));
   SDValue LHS = GetPromotedInteger(N->getOperand(1));
   SDValue RHS = GetPromotedInteger(N->getOperand(2));
   return DAG.getNode(ISD::VSELECT, N->getDebugLoc(),
@@ -508,7 +508,7 @@
 }
 
 SDValue DAGTypeLegalizer::PromoteIntRes_SETCC(SDNode *N) {
-  EVT SVT = TLI.getSetCCResultType(N->getOperand(0).getValueType());
+  EVT SVT = getSetCCResultType(N->getOperand(0).getValueType());
 
   EVT NVT = TLI.getTypeToTransformTo(*DAG.getContext(), N->getValueType(0));
 
@@ -880,7 +880,7 @@
   assert(OpNo == 1 && "only know how to promote condition");
 
   // Promote all the way up to the canonical SetCC type.
-  EVT SVT = TLI.getSetCCResultType(MVT::Other);
+  EVT SVT = getSetCCResultType(MVT::Other);
   SDValue Cond = PromoteTargetBoolean(N->getOperand(1), SVT);
 
   // The chain (Op#0) and basic block destination (Op#2) are always legal types.
@@ -983,7 +983,7 @@
   EVT OpTy = N->getOperand(1).getValueType();
 
   // Promote all the way up to the canonical SetCC type.
-  EVT SVT = TLI.getSetCCResultType(N->getOpcode() == ISD::SELECT ?
+  EVT SVT = getSetCCResultType(N->getOpcode() == ISD::SELECT ?
                                    OpTy.getScalarType() : OpTy);
   Cond = PromoteTargetBoolean(Cond, SVT);
 
@@ -1458,7 +1458,7 @@
   SDValue NVBitsNode = DAG.getConstant(NVTBits, ShTy);
   SDValue AmtExcess = DAG.getNode(ISD::SUB, dl, ShTy, Amt, NVBitsNode);
   SDValue AmtLack = DAG.getNode(ISD::SUB, dl, ShTy, NVBitsNode, Amt);
-  SDValue isShort = DAG.getSetCC(dl, TLI.getSetCCResultType(ShTy),
+  SDValue isShort = DAG.getSetCC(dl, getSetCCResultType(ShTy),
                                  Amt, NVBitsNode, ISD::SETULT);
 
   SDValue LoS, HiS, LoL, HiL;
@@ -1555,12 +1555,12 @@
   if (N->getOpcode() == ISD::ADD) {
     Lo = DAG.getNode(ISD::ADD, dl, NVT, LoOps, 2);
     Hi = DAG.getNode(ISD::ADD, dl, NVT, HiOps, 2);
-    SDValue Cmp1 = DAG.getSetCC(dl, TLI.getSetCCResultType(NVT), Lo, LoOps[0],
+    SDValue Cmp1 = DAG.getSetCC(dl, getSetCCResultType(NVT), Lo, LoOps[0],
                                 ISD::SETULT);
     SDValue Carry1 = DAG.getNode(ISD::SELECT, dl, NVT, Cmp1,
                                  DAG.getConstant(1, NVT),
                                  DAG.getConstant(0, NVT));
-    SDValue Cmp2 = DAG.getSetCC(dl, TLI.getSetCCResultType(NVT), Lo, LoOps[1],
+    SDValue Cmp2 = DAG.getSetCC(dl, getSetCCResultType(NVT), Lo, LoOps[1],
                                 ISD::SETULT);
     SDValue Carry2 = DAG.getNode(ISD::SELECT, dl, NVT, Cmp2,
                                  DAG.getConstant(1, NVT), Carry1);
@@ -1569,7 +1569,7 @@
     Lo = DAG.getNode(ISD::SUB, dl, NVT, LoOps, 2);
     Hi = DAG.getNode(ISD::SUB, dl, NVT, HiOps, 2);
     SDValue Cmp =
-      DAG.getSetCC(dl, TLI.getSetCCResultType(LoOps[0].getValueType()),
+      DAG.getSetCC(dl, getSetCCResultType(LoOps[0].getValueType()),
                    LoOps[0], LoOps[1], ISD::SETULT);
     SDValue Borrow = DAG.getNode(ISD::SELECT, dl, NVT, Cmp,
                                  DAG.getConstant(1, NVT),
@@ -1718,7 +1718,7 @@
   GetExpandedInteger(N->getOperand(0), Lo, Hi);
   EVT NVT = Lo.getValueType();
 
-  SDValue HiNotZero = DAG.getSetCC(dl, TLI.getSetCCResultType(NVT), Hi,
+  SDValue HiNotZero = DAG.getSetCC(dl, getSetCCResultType(NVT), Hi,
                                    DAG.getConstant(0, NVT), ISD::SETNE);
 
   SDValue LoLZ = DAG.getNode(N->getOpcode(), dl, NVT, Lo);
@@ -1748,7 +1748,7 @@
   GetExpandedInteger(N->getOperand(0), Lo, Hi);
   EVT NVT = Lo.getValueType();
 
-  SDValue LoNotZero = DAG.getSetCC(dl, TLI.getSetCCResultType(NVT), Lo,
+  SDValue LoNotZero = DAG.getSetCC(dl, getSetCCResultType(NVT), Lo,
                                    DAG.getConstant(0, NVT), ISD::SETNE);
 
   SDValue LoLZ = DAG.getNode(ISD::CTTZ_ZERO_UNDEF, dl, NVT, Lo);
@@ -2272,7 +2272,7 @@
 
     // A divide for UMULO will be faster than a function call. Select to
     // make sure we aren't using 0.
-    SDValue isZero = DAG.getSetCC(dl, TLI.getSetCCResultType(VT),
+    SDValue isZero = DAG.getSetCC(dl, getSetCCResultType(VT),
                                   RHS, DAG.getConstant(0, VT), ISD::SETEQ);
     SDValue NotZero = DAG.getNode(ISD::SELECT, dl, VT, isZero,
                                   DAG.getConstant(1, VT), RHS);
@@ -2551,16 +2551,16 @@
   // this identity: (B1 ? B2 : B3) --> (B1 & B2)|(!B1&B3)
   TargetLowering::DAGCombinerInfo DagCombineInfo(DAG, false, true, true, NULL);
   SDValue Tmp1, Tmp2;
-  Tmp1 = TLI.SimplifySetCC(TLI.getSetCCResultType(LHSLo.getValueType()),
+  Tmp1 = TLI.SimplifySetCC(getSetCCResultType(LHSLo.getValueType()),
                            LHSLo, RHSLo, LowCC, false, DagCombineInfo, dl);
   if (!Tmp1.getNode())
-    Tmp1 = DAG.getSetCC(dl, TLI.getSetCCResultType(LHSLo.getValueType()),
+    Tmp1 = DAG.getSetCC(dl, getSetCCResultType(LHSLo.getValueType()),
                         LHSLo, RHSLo, LowCC);
-  Tmp2 = TLI.SimplifySetCC(TLI.getSetCCResultType(LHSHi.getValueType()),
+  Tmp2 = TLI.SimplifySetCC(getSetCCResultType(LHSHi.getValueType()),
                            LHSHi, RHSHi, CCCode, false, DagCombineInfo, dl);
   if (!Tmp2.getNode())
     Tmp2 = DAG.getNode(ISD::SETCC, dl,
-                       TLI.getSetCCResultType(LHSHi.getValueType()),
+                       getSetCCResultType(LHSHi.getValueType()),
                        LHSHi, RHSHi, DAG.getCondCode(CCCode));
 
   ConstantSDNode *Tmp1C = dyn_cast<ConstantSDNode>(Tmp1.getNode());
@@ -2580,11 +2580,11 @@
     return;
   }
 
-  NewLHS = TLI.SimplifySetCC(TLI.getSetCCResultType(LHSHi.getValueType()),
+  NewLHS = TLI.SimplifySetCC(getSetCCResultType(LHSHi.getValueType()),
                              LHSHi, RHSHi, ISD::SETEQ, false,
                              DagCombineInfo, dl);
   if (!NewLHS.getNode())
-    NewLHS = DAG.getSetCC(dl, TLI.getSetCCResultType(LHSHi.getValueType()),
+    NewLHS = DAG.getSetCC(dl, getSetCCResultType(LHSHi.getValueType()),
                           LHSHi, RHSHi, ISD::SETEQ);
   NewLHS = DAG.getNode(ISD::SELECT, dl, Tmp1.getValueType(),
                        NewLHS, Tmp1, Tmp2);
@@ -2813,7 +2813,7 @@
     SDValue Lo, Hi;
     GetExpandedInteger(Op, Lo, Hi);
     SDValue SignSet = DAG.getSetCC(dl,
-                                   TLI.getSetCCResultType(Hi.getValueType()),
+                                   getSetCCResultType(Hi.getValueType()),
                                    Hi, DAG.getConstant(0, Hi.getValueType()),
                                    ISD::SETLT);
 
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/LegalizeTypes.h llvm-3.2.src/lib/CodeGen/SelectionDAG/LegalizeTypes.h
--- /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/LegalizeTypes.h	2012-10-10 22:02:15.000000000 +0530
+++ llvm-3.2.src/lib/CodeGen/SelectionDAG/LegalizeTypes.h	2014-08-02 14:41:38.000000000 +0530
@@ -73,6 +73,10 @@
     return TLI.getTypeAction(*DAG.getContext(), VT) == TargetLowering::TypeLegal;
   }
 
+  EVT getSetCCResultType(EVT VT) const {
+    return TLI.getSetCCResultType(*DAG.getContext(), VT);
+  }
+
   /// IgnoreNodeResults - Pretend all of this node's results are legal.
   bool IgnoreNodeResults(SDNode *N) const {
     return N->getOpcode() == ISD::TargetConstant;
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp llvm-3.2.src/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp	2012-09-02 17:51:50.000000000 +0530
+++ llvm-3.2.src/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp	2014-08-02 14:48:32.000000000 +0530
@@ -467,10 +467,7 @@
     return DAG.UnrollVectorOp(Op.getNode());
 
   // Generate a mask operand.
-  EVT MaskTy = TLI.getSetCCResultType(VT);
-  assert(MaskTy.isVector() && "Invalid CC type");
-  assert(MaskTy.getSizeInBits() == Op1.getValueType().getSizeInBits()
-         && "Invalid mask size");
+  EVT MaskTy = VT.changeVectorElementTypeToInteger();
 
   // What is the size of each element in the vector mask.
   EVT BitTy = MaskTy.getScalarType();
@@ -603,7 +600,8 @@
                                   DAG.getIntPtrConstant(i));
     SDValue RHSElem = DAG.getNode(ISD::EXTRACT_VECTOR_ELT, dl, TmpEltVT, RHS,
                                   DAG.getIntPtrConstant(i));
-    Ops[i] = DAG.getNode(ISD::SETCC, dl, TLI.getSetCCResultType(TmpEltVT),
+    Ops[i] = DAG.getNode(ISD::SETCC, dl,
+                         TLI.getSetCCResultType(*DAG.getContext(), TmpEltVT),
                          LHSElem, RHSElem, CC);
     Ops[i] = DAG.getNode(ISD::SELECT, dl, EltVT, Ops[i],
                          DAG.getConstant(APInt::getAllOnesValue
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp llvm-3.2.src/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp	2012-10-10 22:02:15.000000000 +0530
+++ llvm-3.2.src/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp	2014-08-02 14:49:22.000000000 +0530
@@ -2251,7 +2251,7 @@
 
   // Get a new SETCC node to compare the newly widened operands.
   // Only some of the compared elements are legal.
-  EVT SVT = TLI.getSetCCResultType(InOp0.getValueType());
+  EVT SVT = TLI.getSetCCResultType(*DAG.getContext(), InOp0.getValueType());
   SDValue WideSETCC = DAG.getNode(ISD::SETCC, N->getDebugLoc(),
                      SVT, InOp0, InOp1, N->getOperand(2));
 
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp llvm-3.2.src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp	2012-11-02 05:19:58.000000000 +0530
+++ llvm-3.2.src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp	2014-08-02 14:52:56.000000000 +0530
@@ -1701,7 +1701,9 @@
   // for the switch statement if the value being switched on exceeds the largest
   // case in the switch.
   SDValue CMP = DAG.getSetCC(getCurDebugLoc(),
-                             TLI.getSetCCResultType(Sub.getValueType()), Sub,
+                             TLI.getSetCCResultType(*DAG.getContext(),
+                                                    Sub.getValueType()),
+			     Sub,
                              DAG.getConstant(JTH.Last-JTH.First,VT),
                              ISD::SETUGT);
 
@@ -1736,7 +1738,8 @@
 
   // Check range
   SDValue RangeCmp = DAG.getSetCC(getCurDebugLoc(),
-                                  TLI.getSetCCResultType(Sub.getValueType()),
+                                  TLI.getSetCCResultType(*DAG.getContext(),
+                                                         Sub.getValueType()),
                                   Sub, DAG.getConstant(B.Range, VT),
                                   ISD::SETUGT);
 
@@ -1802,14 +1805,14 @@
     // Testing for a single bit; just compare the shift count with what it
     // would need to be to shift a 1 bit in that position.
     Cmp = DAG.getSetCC(getCurDebugLoc(),
-                       TLI.getSetCCResultType(VT),
+                       TLI.getSetCCResultType(*DAG.getContext(), VT),
                        ShiftOp,
                        DAG.getConstant(CountTrailingZeros_64(B.Mask), VT),
                        ISD::SETEQ);
   } else if (PopCount == BB.Range) {
     // There is only one zero bit in the range, test for it directly.
     Cmp = DAG.getSetCC(getCurDebugLoc(),
-                       TLI.getSetCCResultType(VT),
+                       TLI.getSetCCResultType(*DAG.getContext(), VT),
                        ShiftOp,
                        DAG.getConstant(CountTrailingOnes_64(B.Mask), VT),
                        ISD::SETNE);
@@ -1822,7 +1825,7 @@
     SDValue AndOp = DAG.getNode(ISD::AND, getCurDebugLoc(),
                                 VT, SwitchVal, DAG.getConstant(B.Mask, VT));
     Cmp = DAG.getSetCC(getCurDebugLoc(),
-                       TLI.getSetCCResultType(VT),
+                      TLI.getSetCCResultType(*DAG.getContext(), VT),
                        AndOp, DAG.getConstant(0, VT),
                        ISD::SETNE);
   }
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/SelectionDAG.cpp llvm-3.2.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/SelectionDAG.cpp	2012-11-01 14:44:31.000000000 +0530
+++ llvm-3.2.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp	2014-08-18 16:29:25.000000000 +0530
@@ -948,6 +948,14 @@
     getNode(ISD::TRUNCATE, DL, VT, Op);
 }
 
+SDValue SelectionDAG::getBoolExtOrTrunc(SDValue Op, DebugLoc SL, EVT VT) {
+  if (VT.bitsLE(Op.getValueType()))
+    return getNode(ISD::TRUNCATE, SL, VT, Op);
+
+  TargetLowering::BooleanContent BType = TLI.getBooleanContents(VT.isVector());
+  return getNode(TLI.getExtendForContent(BType), SL, VT, Op);
+}
+
 SDValue SelectionDAG::getZeroExtendInReg(SDValue Op, DebugLoc DL, EVT VT) {
   assert(!VT.isVector() &&
          "getZeroExtendInReg should use the vector element type instead of "
@@ -1651,7 +1659,12 @@
       }
     } else {
       // Ensure that the constant occurs on the RHS.
-      return getSetCC(dl, VT, N2, N1, ISD::getSetCCSwappedOperands(Cond));
+      ISD::CondCode SwappedCond = ISD::getSetCCSwappedOperands(Cond);
+      MVT CompVT = N1.getValueType().getSimpleVT();
+      if (!TM.getTargetLowering()->isCondCodeLegal(SwappedCond, CompVT))
+        return SDValue();
+
+      return getSetCC(dl, VT, N2, N1, SwappedCond);
     }
   }
 
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/TargetLowering.cpp llvm-3.2.src/lib/CodeGen/SelectionDAG/TargetLowering.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/CodeGen/SelectionDAG/TargetLowering.cpp	2012-11-02 05:19:58.000000000 +0530
+++ llvm-3.2.src/lib/CodeGen/SelectionDAG/TargetLowering.cpp	2014-08-18 16:29:09.000000000 +0530
@@ -904,7 +904,7 @@
   return NULL;
 }
 
-EVT TargetLowering::getSetCCResultType(EVT VT) const {
+EVT TargetLowering::getSetCCResultType(LLVMContext &, EVT VT) const {
   assert(!VT.isVector() && "No default SetCC type for vectors!");
   return getPointerTy(0).SimpleTy;
 }
@@ -1923,8 +1923,11 @@
 
   // Ensure that the constant occurs on the RHS, and fold constant
   // comparisons.
-  if (isa<ConstantSDNode>(N0.getNode()))
-    return DAG.getSetCC(dl, VT, N1, N0, ISD::getSetCCSwappedOperands(Cond));
+  ISD::CondCode SwappedCC = ISD::getSetCCSwappedOperands(Cond);
+  if (isa<ConstantSDNode>(N0.getNode()) &&
+      (DCI.isBeforeLegalizeOps() ||
+       isCondCodeLegal(SwappedCC, N0.getValueType())))
+    return DAG.getSetCC(dl, VT, N1, N0, SwappedCC);
 
   if (ConstantSDNode *N1C = dyn_cast<ConstantSDNode>(N1.getNode())) {
     const APInt &C1 = N1C->getAPIntValue();
@@ -2111,10 +2114,14 @@
         EVT newVT = N0.getOperand(0).getValueType();
         if (DCI.isBeforeLegalizeOps() ||
             (isOperationLegal(ISD::SETCC, newVT) &&
-              getCondCodeAction(Cond, newVT)==Legal))
-          return DAG.getSetCC(dl, VT, N0.getOperand(0),
-                              DAG.getConstant(C1.trunc(InSize), newVT),
-                              Cond);
+             getCondCodeAction(Cond, newVT)==Legal)) {
+          	EVT NewSetCCVT = getSetCCResultType(*DAG.getContext(), newVT);
+	        SDValue NewConst = DAG.getConstant(C1.trunc(InSize), newVT);
+
+          	SDValue NewSetCC = DAG.getSetCC(dl, NewSetCCVT, N0.getOperand(0),
+                                          NewConst, Cond);
+          	return DAG.getBoolExtOrTrunc(NewSetCC, dl, VT);
+	}
         break;
       }
       default:
@@ -2162,7 +2169,9 @@
         ISD::CondCode CC = cast<CondCodeSDNode>(N0.getOperand(2))->get();
         CC = ISD::getSetCCInverse(CC,
                                   N0.getOperand(0).getValueType().isInteger());
-        return DAG.getSetCC(dl, VT, N0.getOperand(0), N0.getOperand(1), CC);
+        if (DCI.isBeforeLegalizeOps() ||
+            isCondCodeLegal(CC, N0.getOperand(0).getValueType()))
+          return DAG.getSetCC(dl, VT, N0.getOperand(0), N0.getOperand(1), CC);
       }
 
       if ((N0.getOpcode() == ISD::XOR ||
@@ -2593,16 +2602,22 @@
       if (N0.getOperand(0) == N1 || N0.getOperand(1) == N1) {
         if (ValueHasExactlyOneBitSet(N1, DAG)) {
           Cond = ISD::getSetCCInverse(Cond, /*isInteger=*/true);
-          SDValue Zero = DAG.getConstant(0, N1.getValueType());
-          return DAG.getSetCC(dl, VT, N0, Zero, Cond);
+          if (DCI.isBeforeLegalizeOps() ||
+              isCondCodeLegal(Cond, N0.getValueType())) {
+            SDValue Zero = DAG.getConstant(0, N1.getValueType());
+            return DAG.getSetCC(dl, VT, N0, Zero, Cond);
+          }
         }
       }
     if (N1.getOpcode() == ISD::AND)
       if (N1.getOperand(0) == N0 || N1.getOperand(1) == N0) {
         if (ValueHasExactlyOneBitSet(N0, DAG)) {
           Cond = ISD::getSetCCInverse(Cond, /*isInteger=*/true);
-          SDValue Zero = DAG.getConstant(0, N0.getValueType());
-          return DAG.getSetCC(dl, VT, N1, Zero, Cond);
+          if (DCI.isBeforeLegalizeOps() ||
+              isCondCodeLegal(Cond, N1.getValueType())) {
+            SDValue Zero = DAG.getConstant(0, N0.getValueType());
+            return DAG.getSetCC(dl, VT, N1, Zero, Cond);
+          }
         }
       }
   }
Only in llvm-3.2.src/lib/Linker: AMDResolveLinker.cpp
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/Linker/CMakeLists.txt llvm-3.2.src/lib/Linker/CMakeLists.txt
--- /home/amd/Prakash/llvm-3.2.org/lib/Linker/CMakeLists.txt	2011-11-30 00:55:30.000000000 +0530
+++ llvm-3.2.src/lib/Linker/CMakeLists.txt	2014-07-24 17:06:05.000000000 +0530
@@ -3,4 +3,5 @@
   LinkItems.cpp
   LinkModules.cpp
   Linker.cpp
+  AMDResolveLinker.cpp
   )
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/Linker/LinkModules.cpp llvm-3.2.src/lib/Linker/LinkModules.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/Linker/LinkModules.cpp	2012-08-03 06:00:35.000000000 +0530
+++ llvm-3.2.src/lib/Linker/LinkModules.cpp	2014-08-18 16:38:44.000000000 +0530
@@ -180,7 +180,7 @@
     if (DATy->getNumElements() != cast<ArrayType>(SrcTy)->getNumElements())
       return false;
   } else if (VectorType *DVTy = dyn_cast<VectorType>(DstTy)) {
-    if (DVTy->getNumElements() != cast<ArrayType>(SrcTy)->getNumElements())
+    if (DVTy->getNumElements() != cast<VectorType>(SrcTy)->getNumElements())
       return false;
   }
 
@@ -372,7 +372,9 @@
     
     // Set of items not to link in from source.
     SmallPtrSet<const Value*, 16> DoNotLinkFromSource;
-    
+
+    std::map<const Value*, bool> *pReferenceMap;
+
     // Vector of functions to lazily link in.
     std::vector<Function*> LazilyLinkFunctions;
     
@@ -380,8 +382,16 @@
     std::string ErrorMsg;
     
     ModuleLinker(Module *dstM, Module *srcM, unsigned mode)
-      : DstM(dstM), SrcM(srcM), Mode(mode) { }
-    
+      : DstM(dstM), SrcM(srcM), Mode(mode)
+      , pReferenceMap(0)
+    {}
+
+    ModuleLinker(Module *dstM, Module *srcM, unsigned mode,
+                 std::map<const Value*, bool> *pRefMap
+                 )
+      : DstM(dstM), SrcM(srcM), Mode(mode), pReferenceMap(pRefMap)
+    { }
+
     bool run();
     
   private:
@@ -640,7 +650,13 @@
   }
 
   // Don't bother incorporating aliases, they aren't generally typed well.
-  
+  // Assume aliaser and aliasee's types are exactly the same
+  for (Module::alias_iterator I = SrcM->alias_begin(), E = SrcM->alias_end();
+       I != E; ++I) {
+    if (GlobalValue *DGV = getLinkedToGlobal(I))
+      TypeMap.addTypeMapping(DGV->getType(), I->getType());
+  }
+
   // Now that we have discovered all of the type equivalences, get a body for
   // any 'opaque' types in the dest module that are now resolved. 
   TypeMap.linkDefinedTypeBodies();
@@ -962,6 +978,8 @@
 void ModuleLinker::linkAliasBodies() {
   for (Module::alias_iterator I = SrcM->alias_begin(), E = SrcM->alias_end();
        I != E; ++I) {
+    if (pReferenceMap && !(*pReferenceMap)[I])
+      continue;
     if (DoNotLinkFromSource.count(I))
       continue;
     if (Constant *Aliasee = I->getAliasee()) {
@@ -1216,14 +1234,21 @@
   // all of the global values that may be referenced are available in our
   // ValueMap.
   for (Module::iterator I = SrcM->begin(), E = SrcM->end(); I != E; ++I)
+  {
+    if (pReferenceMap && !(*pReferenceMap)[I])
+      continue;
     if (linkFunctionProto(I))
       return true;
+  }
 
   // If there were any aliases, link them now.
   for (Module::alias_iterator I = SrcM->alias_begin(),
-       E = SrcM->alias_end(); I != E; ++I)
+       E = SrcM->alias_end(); I != E; ++I) {
+    if (pReferenceMap && !(*pReferenceMap)[I])
+      continue;
     if (linkAliasProto(I))
       return true;
+  }
 
   for (unsigned i = 0, e = AppendingVars.size(); i != e; ++i)
     linkAppendingVarInit(AppendingVars[i]);
@@ -1235,6 +1260,10 @@
   // Link in the function bodies that are defined in the source module into
   // DstM.
   for (Module::iterator SF = SrcM->begin(), E = SrcM->end(); SF != E; ++SF) {
+
+    if (pReferenceMap && !(*pReferenceMap)[SF])
+      continue;
+
     // Skip if not linking from source.
     if (DoNotLinkFromSource.count(SF)) continue;
     
@@ -1338,16 +1367,14 @@
   return false;
 }
 
-//===----------------------------------------------------------------------===//
-// C API.
-//===----------------------------------------------------------------------===//
+bool Linker::LinkModules(Module *Dest, Module *Src, unsigned Mode,
+                         std::map<const Value*, bool> *ReferenceMap,
+                         std::string *ErrorMsg) {
+  ModuleLinker TheLinker(Dest, Src, Mode, ReferenceMap);
+  if (TheLinker.run()) {
+    if (ErrorMsg) *ErrorMsg = TheLinker.ErrorMsg;
+    return true;
+  }
 
-LLVMBool LLVMLinkModules(LLVMModuleRef Dest, LLVMModuleRef Src,
-                         LLVMLinkerMode Mode, char **OutMessages) {
-  std::string Messages;
-  LLVMBool Result = Linker::LinkModules(unwrap(Dest), unwrap(Src),
-                                        Mode, OutMessages? &Messages : 0);
-  if (OutMessages)
-    *OutMessages = strdup(Messages.c_str());
-  return Result;
+  return false;
 }
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/MC/MCELFStreamer.cpp llvm-3.2.src/lib/MC/MCELFStreamer.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/MC/MCELFStreamer.cpp	2012-10-15 21:13:14.000000000 +0530
+++ llvm-3.2.src/lib/MC/MCELFStreamer.cpp	2014-07-21 15:59:42.000000000 +0530
@@ -11,6 +11,7 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "llvm/MC/MCELFStreamer.h"
 #include "MCELF.h"
 #include "llvm/ADT/SmallPtrSet.h"
 #include "llvm/ADT/StringExtras.h"
@@ -35,119 +36,6 @@
 
 using namespace llvm;
 
-namespace {
-class MCELFStreamer : public MCObjectStreamer {
-public:
-  MCELFStreamer(MCContext &Context, MCAsmBackend &TAB,
-                  raw_ostream &OS, MCCodeEmitter *Emitter)
-    : MCObjectStreamer(Context, TAB, OS, Emitter) {}
-
-  MCELFStreamer(MCContext &Context, MCAsmBackend &TAB,
-                raw_ostream &OS, MCCodeEmitter *Emitter,
-                MCAssembler *Assembler)
-    : MCObjectStreamer(Context, TAB, OS, Emitter, Assembler) {}
-
-
-  ~MCELFStreamer() {}
-
-  /// @name MCStreamer Interface
-  /// @{
-
-  virtual void InitSections();
-  virtual void ChangeSection(const MCSection *Section);
-  virtual void EmitLabel(MCSymbol *Symbol);
-  virtual void EmitAssemblerFlag(MCAssemblerFlag Flag);
-  virtual void EmitThumbFunc(MCSymbol *Func);
-  virtual void EmitAssignment(MCSymbol *Symbol, const MCExpr *Value);
-  virtual void EmitWeakReference(MCSymbol *Alias, const MCSymbol *Symbol);
-  virtual void EmitSymbolAttribute(MCSymbol *Symbol, MCSymbolAttr Attribute);
-  virtual void EmitSymbolDesc(MCSymbol *Symbol, unsigned DescValue) {
-    llvm_unreachable("ELF doesn't support this directive");
-  }
-  virtual void EmitCommonSymbol(MCSymbol *Symbol, uint64_t Size,
-                                unsigned ByteAlignment);
-  virtual void BeginCOFFSymbolDef(const MCSymbol *Symbol) {
-    llvm_unreachable("ELF doesn't support this directive");
-  }
-
-  virtual void EmitCOFFSymbolStorageClass(int StorageClass) {
-    llvm_unreachable("ELF doesn't support this directive");
-  }
-
-  virtual void EmitCOFFSymbolType(int Type) {
-    llvm_unreachable("ELF doesn't support this directive");
-  }
-
-  virtual void EndCOFFSymbolDef() {
-    llvm_unreachable("ELF doesn't support this directive");
-  }
-
-  virtual void EmitELFSize(MCSymbol *Symbol, const MCExpr *Value) {
-     MCSymbolData &SD = getAssembler().getOrCreateSymbolData(*Symbol);
-     SD.setSize(Value);
-  }
-
-  virtual void EmitLocalCommonSymbol(MCSymbol *Symbol, uint64_t Size,
-                                     unsigned ByteAlignment);
-
-  virtual void EmitZerofill(const MCSection *Section, MCSymbol *Symbol = 0,
-                            uint64_t Size = 0, unsigned ByteAlignment = 0) {
-    llvm_unreachable("ELF doesn't support this directive");
-  }
-  virtual void EmitTBSSSymbol(const MCSection *Section, MCSymbol *Symbol,
-                              uint64_t Size, unsigned ByteAlignment = 0) {
-    llvm_unreachable("ELF doesn't support this directive");
-  }
-  virtual void EmitValueImpl(const MCExpr *Value, unsigned Size,
-                             unsigned AddrSpace);
-
-  virtual void EmitFileDirective(StringRef Filename);
-
-  virtual void EmitTCEntry(const MCSymbol &S);
-
-  virtual void FinishImpl();
-
-private:
-  virtual void EmitInstToFragment(const MCInst &Inst);
-  virtual void EmitInstToData(const MCInst &Inst);
-
-  void fixSymbolsInTLSFixups(const MCExpr *expr);
-
-  struct LocalCommon {
-    MCSymbolData *SD;
-    uint64_t Size;
-    unsigned ByteAlignment;
-  };
-  std::vector<LocalCommon> LocalCommons;
-
-  SmallPtrSet<MCSymbol *, 16> BindingExplicitlySet;
-  /// @}
-  void SetSection(StringRef Section, unsigned Type, unsigned Flags,
-                  SectionKind Kind) {
-    SwitchSection(getContext().getELFSection(Section, Type, Flags, Kind));
-  }
-
-  void SetSectionData() {
-    SetSection(".data", ELF::SHT_PROGBITS,
-               ELF::SHF_WRITE |ELF::SHF_ALLOC,
-               SectionKind::getDataRel());
-    EmitCodeAlignment(4, 0);
-  }
-  void SetSectionText() {
-    SetSection(".text", ELF::SHT_PROGBITS,
-               ELF::SHF_EXECINSTR |
-               ELF::SHF_ALLOC, SectionKind::getText());
-    EmitCodeAlignment(4, 0);
-  }
-  void SetSectionBss() {
-    SetSection(".bss", ELF::SHT_NOBITS,
-               ELF::SHF_WRITE |
-               ELF::SHF_ALLOC, SectionKind::getBSS());
-    EmitCodeAlignment(4, 0);
-  }
-};
-}
-
 void MCELFStreamer::InitSections() {
   // This emulates the same behavior of GNU as. This makes it easier
   // to compare the output as the major sections are in the same order.
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/Support/Triple.cpp llvm-3.2.src/lib/Support/Triple.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/Support/Triple.cpp	2012-11-16 02:54:48.000000000 +0530
+++ llvm-3.2.src/lib/Support/Triple.cpp	2014-08-19 14:20:52.000000000 +0530
@@ -41,7 +41,9 @@
   case nvptx:   return "nvptx";
   case nvptx64: return "nvptx64";
   case le32:    return "le32";
-  case amdil:   return "amdil";
+  case hsail:   return "hsail";
+  case hsail_64:return "hsail64";
+  case amdil:	return "amdil";
   case spir:    return "spir";
   case spir64:  return "spir64";
   }
@@ -84,7 +86,9 @@
   case nvptx:   return "nvptx";
   case nvptx64: return "nvptx";
   case le32:    return "le32";
-  case amdil:   return "amdil";
+  case hsail:   return "hsail";
+  case hsail_64:return "hsail64";
+  case amdil:	return "amdil";
   case spir:    return "spir";
   case spir64:  return "spir";
   }
@@ -177,6 +181,8 @@
     .Case("nvptx", nvptx)
     .Case("nvptx64", nvptx64)
     .Case("le32", le32)
+    .Case("hsail", hsail)
+    .Case("hsail64", hsail_64)
     .Case("amdil", amdil)
     .Case("spir", spir)
     .Case("spir64", spir64)
@@ -203,6 +209,8 @@
     .Case("nvptx", "nvptx")
     .Case("nvptx64", "nvptx64")
     .Case("le32", "le32")
+    .Case("hsail", "hsail")
+    .Case("hsail64", "hsail_64")
     .Case("amdil", "amdil")
     .Case("spir", "spir")
     .Case("spir64", "spir64")
@@ -239,6 +247,8 @@
     .Case("nvptx", Triple::nvptx)
     .Case("nvptx64", Triple::nvptx64)
     .Case("le32", Triple::le32)
+    .Case("hsail", Triple::hsail)
+    .Case("hsail64", Triple::hsail_64)
     .Case("amdil", Triple::amdil)
     .Case("spir", Triple::spir)
     .Case("spir64", Triple::spir64)
@@ -678,8 +688,10 @@
   case llvm::Triple::x86:
   case llvm::Triple::xcore:
   case llvm::Triple::spir:
+  case llvm::Triple::hsail:
     return 32;
 
+  case llvm::Triple::hsail_64:
   case llvm::Triple::mips64:
   case llvm::Triple::mips64el:
   case llvm::Triple::nvptx64:
@@ -729,9 +741,11 @@
   case Triple::thumb:
   case Triple::x86:
   case Triple::xcore:
+  case Triple::hsail:
     // Already 32-bit.
     break;
 
+  case Triple::hsail_64:  T.setArch(Triple::hsail); break;
   case Triple::mips64:    T.setArch(Triple::mips);    break;
   case Triple::mips64el:  T.setArch(Triple::mipsel);  break;
   case Triple::nvptx64:   T.setArch(Triple::nvptx);   break;
@@ -747,7 +761,6 @@
   Triple T(*this);
   switch (getArch()) {
   case Triple::UnknownArch:
-  case Triple::amdil:
   case Triple::arm:
   case Triple::cellspu:
   case Triple::hexagon:
@@ -762,6 +775,7 @@
     break;
 
   case Triple::spir64:
+  case Triple::hsail_64:
   case Triple::mips64:
   case Triple::mips64el:
   case Triple::nvptx64:
@@ -771,6 +785,7 @@
     // Already 64-bit.
     break;
 
+  case Triple::hsail:   T.setArch(Triple::hsail_64);  break;
   case Triple::mips:    T.setArch(Triple::mips64);    break;
   case Triple::mipsel:  T.setArch(Triple::mips64el);  break;
   case Triple::nvptx:   T.setArch(Triple::nvptx64);   break;
@@ -781,3 +796,4 @@
   }
   return T;
 }
+
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/TableGen/Record.cpp llvm-3.2.src/lib/TableGen/Record.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/TableGen/Record.cpp	2012-10-26 02:03:17.000000000 +0530
+++ llvm-3.2.src/lib/TableGen/Record.cpp	2014-07-21 17:48:01.000000000 +0530
@@ -904,6 +904,7 @@
 
     break;
   }
+  case ADD:
   case SHL:
   case SRA:
   case SRL: {
@@ -914,6 +915,7 @@
       int64_t Result;
       switch (getOpcode()) {
       default: llvm_unreachable("Bad opcode!");
+      case ADD: Result = LHSv +  RHSv; break;
       case SHL: Result = LHSv << RHSv; break;
       case SRA: Result = LHSv >> RHSv; break;
       case SRL: Result = (uint64_t)LHSv >> (uint64_t)RHSv; break;
@@ -939,6 +941,7 @@
   std::string Result;
   switch (Opc) {
   case CONCAT: Result = "!con"; break;
+  case ADD: Result = "!add"; break;
   case SHL: Result = "!shl"; break;
   case SRA: Result = "!sra"; break;
   case SRL: Result = "!srl"; break;
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/TableGen/TGLexer.cpp llvm-3.2.src/lib/TableGen/TGLexer.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/TableGen/TGLexer.cpp	2012-02-22 21:39:41.000000000 +0530
+++ llvm-3.2.src/lib/TableGen/TGLexer.cpp	2014-07-21 17:48:26.000000000 +0530
@@ -463,6 +463,7 @@
     .Case("head", tgtok::XHead)
     .Case("tail", tgtok::XTail)
     .Case("con", tgtok::XConcat)
+    .Case("add", tgtok::XADD)
     .Case("shl", tgtok::XSHL)
     .Case("sra", tgtok::XSRA)
     .Case("srl", tgtok::XSRL)
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/TableGen/TGLexer.h llvm-3.2.src/lib/TableGen/TGLexer.h
--- /home/amd/Prakash/llvm-3.2.org/lib/TableGen/TGLexer.h	2012-02-22 21:39:41.000000000 +0530
+++ llvm-3.2.src/lib/TableGen/TGLexer.h	2014-07-21 17:48:26.000000000 +0530
@@ -46,7 +46,7 @@
     MultiClass, String,
     
     // !keywords.
-    XConcat, XSRA, XSRL, XSHL, XStrConcat, XCast, XSubst,
+    XConcat, XADD, XSRA, XSRL, XSHL, XStrConcat, XCast, XSubst,
     XForEach, XHead, XTail, XEmpty, XIf, XEq,
 
     // Integer value.
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/TableGen/TGParser.cpp llvm-3.2.src/lib/TableGen/TGParser.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/TableGen/TGParser.cpp	2012-10-11 01:54:47.000000000 +0530
+++ llvm-3.2.src/lib/TableGen/TGParser.cpp	2014-07-21 17:48:34.000000000 +0530
@@ -918,6 +918,7 @@
   }
 
   case tgtok::XConcat:
+  case tgtok::XADD:
   case tgtok::XSRA:
   case tgtok::XSRL:
   case tgtok::XSHL:
@@ -933,6 +934,7 @@
     switch (OpTok) {
     default: llvm_unreachable("Unhandled code!");
     case tgtok::XConcat: Code = BinOpInit::CONCAT;Type = DagRecTy::get(); break;
+    case tgtok::XADD:    Code = BinOpInit::ADD;   Type = IntRecTy::get(); break;
     case tgtok::XSRA:    Code = BinOpInit::SRA;   Type = IntRecTy::get(); break;
     case tgtok::XSRL:    Code = BinOpInit::SRL;   Type = IntRecTy::get(); break;
     case tgtok::XSHL:    Code = BinOpInit::SHL;   Type = IntRecTy::get(); break;
@@ -1401,6 +1403,7 @@
   case tgtok::XEmpty:
   case tgtok::XCast:  // Value ::= !unop '(' Value ')'
   case tgtok::XConcat:
+  case tgtok::XADD:
   case tgtok::XSRA:
   case tgtok::XSRL:
   case tgtok::XSHL:
Only in /home/amd/Prakash/llvm-3.2.org/lib/Target: ARM
Only in /home/amd/Prakash/llvm-3.2.org/lib/Target: CellSPU
Only in /home/amd/Prakash/llvm-3.2.org/lib/Target: CppBackend
Only in /home/amd/Prakash/llvm-3.2.org/lib/Target: Hexagon
Only in llvm-3.2.src/lib/Target: HSAIL
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/Target/LLVMBuild.txt llvm-3.2.src/lib/Target/LLVMBuild.txt
--- /home/amd/Prakash/llvm-3.2.org/lib/Target/LLVMBuild.txt	2012-07-16 23:49:46.000000000 +0530
+++ llvm-3.2.src/lib/Target/LLVMBuild.txt	2014-07-21 15:59:42.000000000 +0530
@@ -16,7 +16,7 @@
 ;===------------------------------------------------------------------------===;
 
 [common]
-subdirectories = ARM CellSPU CppBackend Hexagon MBlaze MSP430 NVPTX Mips PowerPC Sparc X86 XCore
+subdirectories = X86 HSAIL
 
 ; This is a special group whose required libraries are extended (by llvm-build)
 ; with the best execution engine (the native JIT, if available, or the
Only in /home/amd/Prakash/llvm-3.2.org/lib/Target: MBlaze
Only in /home/amd/Prakash/llvm-3.2.org/lib/Target: Mips
Only in /home/amd/Prakash/llvm-3.2.org/lib/Target: MSP430
Only in /home/amd/Prakash/llvm-3.2.org/lib/Target: NVPTX
Only in /home/amd/Prakash/llvm-3.2.org/lib/Target: PowerPC
Only in /home/amd/Prakash/llvm-3.2.org/lib/Target: PTX
Only in /home/amd/Prakash/llvm-3.2.org/lib/Target: Sparc
Only in /home/amd/Prakash/llvm-3.2.org/lib/Target: XCore
Only in llvm-3.2.src/lib/Transforms/IPO: AMDSymbolLinkage.cpp
Only in llvm-3.2.src/lib/Transforms/IPO: AMDSymbolName.h
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/Transforms/IPO/CMakeLists.txt llvm-3.2.src/lib/Transforms/IPO/CMakeLists.txt
--- /home/amd/Prakash/llvm-3.2.org/lib/Transforms/IPO/CMakeLists.txt	2012-10-18 13:35:46.000000000 +0530
+++ llvm-3.2.src/lib/Transforms/IPO/CMakeLists.txt	2014-07-28 21:10:44.000000000 +0530
@@ -20,6 +20,7 @@
   PruneEH.cpp
   StripDeadPrototypes.cpp
   StripSymbols.cpp
+  AMDSymbolLinkage.cpp
   )
 
 add_dependencies(LLVMipo intrinsics_gen)
diff -ur /home/amd/Prakash/llvm-3.2.org/lib/Transforms/IPO/IPO.cpp llvm-3.2.src/lib/Transforms/IPO/IPO.cpp
--- /home/amd/Prakash/llvm-3.2.org/lib/Transforms/IPO/IPO.cpp	2012-10-27 00:17:48.000000000 +0530
+++ llvm-3.2.src/lib/Transforms/IPO/IPO.cpp	2014-08-18 16:40:44.000000000 +0530
@@ -44,6 +44,7 @@
   initializeStripDebugDeclarePass(Registry);
   initializeStripDeadDebugInfoPass(Registry);
   initializeStripNonDebugSymbolsPass(Registry);
+  initializeAMDSymbolLinkagePass(Registry);
 }
 
 void LLVMInitializeIPO(LLVMPassRegistryRef R) {
diff -ur /home/amd/Prakash/llvm-3.2.org/tools/CMakeLists.txt llvm-3.2.src/tools/CMakeLists.txt
--- /home/amd/Prakash/llvm-3.2.org/tools/CMakeLists.txt	2012-11-01 04:54:13.000000000 +0530
+++ llvm-3.2.src/tools/CMakeLists.txt	2014-09-03 10:34:35.631248915 +0530
@@ -11,7 +11,7 @@
 add_subdirectory(opt)
 add_subdirectory(llvm-as)
 add_subdirectory(llvm-dis)
-add_subdirectory(llvm-mc)
+#add_subdirectory(llvm-mc)
 
 add_subdirectory(llc)
 add_subdirectory(llvm-ranlib)
@@ -27,7 +27,7 @@
 add_subdirectory(llvm-extract)
 add_subdirectory(llvm-diff)
 add_subdirectory(macho-dump)
-add_subdirectory(llvm-objdump)
+#add_subdirectory(llvm-objdump)
 add_subdirectory(llvm-readobj)
 add_subdirectory(llvm-rtdyld)
 add_subdirectory(llvm-dwarfdump)
diff -ur /home/amd/Prakash/llvm-3.2.org/tools/llc/CMakeLists.txt llvm-3.2.src/tools/llc/CMakeLists.txt
--- /home/amd/Prakash/llvm-3.2.org/tools/llc/CMakeLists.txt	2010-09-14 05:29:48.000000000 +0530
+++ llvm-3.2.src/tools/llc/CMakeLists.txt	2014-07-29 11:17:09.000000000 +0530
@@ -1,5 +1,13 @@
+set (USEDLIBS LLVMLibHSAIL.a)
 set(LLVM_LINK_COMPONENTS ${LLVM_TARGETS_TO_BUILD} bitreader asmparser)
 
+add_library(LIBHSAIL STATIC IMPORTED)
+add_library(LIBHSAIL64 STATIC IMPORTED)
+set_property(TARGET LIBHSAIL64 PROPERTY IMPORTED_LOCATION /home/amd/Prakash/Git/HSAIL-Tools-private/libHSAIL/build_linux_opt_m64/libhsail.a)
+
 add_llvm_tool(llc
-  llc.cpp
-  )
+          llc.cpp
+            )
+
+target_link_libraries(llc LIBHSAIL64)
+
diff -ur /home/amd/Prakash/llvm-3.2.org/tools/llc/llc.cpp llvm-3.2.src/tools/llc/llc.cpp
--- /home/amd/Prakash/llvm-3.2.org/tools/llc/llc.cpp	2012-10-19 04:52:48.000000000 +0530
+++ llvm-3.2.src/tools/llc/llc.cpp	2014-08-18 16:50:53.000000000 +0530
@@ -124,7 +124,7 @@
   }
 
   // Decide if we need "binary" output.
-  bool Binary = false;
+  bool Binary = true;
   switch (FileType) {
   case TargetMachine::CGFT_AssemblyFile:
     break;
diff -ur /home/amd/Prakash/llvm-3.2.org/tools/LLVMBuild.txt llvm-3.2.src/tools/LLVMBuild.txt
--- /home/amd/Prakash/llvm-3.2.org/tools/LLVMBuild.txt	2012-11-01 04:54:13.000000000 +0530
+++ llvm-3.2.src/tools/LLVMBuild.txt	2014-07-21 15:59:42.000000000 +0530
@@ -16,7 +16,7 @@
 ;===------------------------------------------------------------------------===;
 
 [common]
-subdirectories = bugpoint llc lli llvm-ar llvm-as llvm-bcanalyzer llvm-cov llvm-diff llvm-dis llvm-dwarfdump llvm-extract llvm-link llvm-mc llvm-nm llvm-objdump llvm-prof llvm-ranlib llvm-rtdyld llvm-size macho-dump opt llvm-mcmarkup
+subdirectories = bugpoint llc lli llvm-ar llvm-as llvm-bcanalyzer llvm-cov llvm-diff llvm-dis llvm-dwarfdump llvm-extract llvm-link llvm-nm llvm-objdump llvm-prof llvm-ranlib llvm-rtdyld llvm-size macho-dump opt llvm-mcmarkup
 
 [component_0]
 type = Group
diff -ur /home/amd/Prakash/llvm-3.2.org/tools/llvm-link/llvm-link.cpp llvm-3.2.src/tools/llvm-link/llvm-link.cpp
--- /home/amd/Prakash/llvm-3.2.org/tools/llvm-link/llvm-link.cpp	2011-10-16 10:17:35.000000000 +0530
+++ llvm-3.2.src/tools/llvm-link/llvm-link.cpp	2014-08-18 16:50:30.000000000 +0530
@@ -25,7 +25,9 @@
 #include "llvm/Support/IRReader.h"
 #include "llvm/Support/Signals.h"
 #include "llvm/Support/Path.h"
+#include "llvm/AMDResolveLinker.h"
 #include <memory>
+
 using namespace llvm;
 
 static cl::list<std::string>
@@ -49,6 +51,17 @@
 static cl::opt<bool>
 DumpAsm("d", cl::desc("Print assembly as linked"), cl::Hidden);
 
+static cl::opt<bool>
+PreLinkOpt("prelink-opt", cl::desc("Enable pre-link optimizations"));
+
+static cl::opt<bool>
+EnableWholeProgram("whole", cl::desc("Enable whole program mode"));
+
+static cl::list<std::string> Libraries("l", cl::Prefix,
+                                       cl::desc("Specify libraries to link to"),
+                                       cl::value_desc("library prefix"));
+
+
 // LoadFile - Read the specified bitcode file in and return it.  This routine
 // searches the link path for the specified file to try to find it...
 //
@@ -114,6 +127,32 @@
   // TODO: Iterate over the -l list and link in any modules containing
   // global symbols that have not been resolved so far.
 
+
+  // Link unresolved symbols from libraries
+  std::vector<Module*> Libs;
+  for (std::vector<std::string>::iterator i = Libraries.begin(),
+       e = Libraries.end(); i != e; ++i) {
+    std::auto_ptr<Module> M(LoadFile(argv[0], *i, Context));
+    if (M.get() == 0) {
+      SMDiagnostic Err(*i, SourceMgr::DK_Error, "error loading file");
+      Err.print(argv[0], errs());
+      return 1;
+    }
+    if (Verbose) errs() << "Linking in '" << *i << "'\n";
+    Libs.push_back(M.get());
+    M.release();
+  }
+
+  if (Libs.size() > 0) {
+    std::string ErrorMsg;
+    if (resolveLink(Composite.get(), Libs, &ErrorMsg)) {
+      SMDiagnostic Err(InputFilenames[BaseArg], SourceMgr::DK_Error, ErrorMsg);
+      Err.print(argv[0], errs());
+      return 1;
+    }
+  }
+
+
   if (DumpAsm) errs() << "Here's the assembly:\n" << *Composite;
 
   std::string ErrorInfo;
diff -ur /home/amd/Prakash/llvm-3.2.org/tools/opt/opt.cpp llvm-3.2.src/tools/opt/opt.cpp
--- /home/amd/Prakash/llvm-3.2.org/tools/opt/opt.cpp	2012-10-24 23:25:53.000000000 +0530
+++ llvm-3.2.src/tools/opt/opt.cpp	2014-08-18 16:51:25.000000000 +0530
@@ -156,6 +156,12 @@
           cl::desc("data layout string to use if not specified by module"),
           cl::value_desc("layout-string"), cl::init(""));
 
+static cl::opt<bool>
+EnableWholeProgram("whole", cl::desc("Enable whole program mode"));
+
+static cl::opt<bool>
+EnableGPUOpt("gpu", cl::desc("Enable optimization for GPU"));
+
 // ---------- Define Printers for module and function passes ------------
 namespace {
 
@@ -442,6 +448,13 @@
   } else {
     Builder.Inliner = createAlwaysInlinerPass();
   }
+
+
+  MPM.add(createAMDSymbolLinkagePass(EnableWholeProgram));
+  MPM.add(createAlwaysInlinerPass());
+  MPM.add(createGlobalOptimizerPass());     // Optimize out global vars
+  MPM.add(createGlobalDCEPass());         // Remove dead fns and globals.
+
   Builder.DisableUnitAtATime = !UnitAtATime;
   Builder.DisableUnrollLoops = OptLevel == 0;
   Builder.DisableSimplifyLibCalls = DisableSimplifyLibCalls;
@@ -707,6 +720,11 @@
       StandardLinkOpts = false;
     }
 
+    Passes.add(createAMDSymbolLinkagePass(EnableWholeProgram));
+    Passes.add(createAlwaysInlinerPass());
+    Passes.add(createGlobalOptimizerPass());     // Optimize out global vars
+    Passes.add(createGlobalDCEPass());         // Remove dead fns and globals.
+
     if (OptLevelO1 && OptLevelO1.getPosition() < PassList.getPosition(i)) {
       AddOptimizationPasses(Passes, *FPasses, 1, 0);
       OptLevelO1 = false;
Binary files /home/amd/Prakash/llvm-3.2.org/utils/llvm-build/llvmbuild/componentinfo.pyc and llvm-3.2.src/utils/llvm-build/llvmbuild/componentinfo.pyc differ
Binary files /home/amd/Prakash/llvm-3.2.org/utils/llvm-build/llvmbuild/configutil.pyc and llvm-3.2.src/utils/llvm-build/llvmbuild/configutil.pyc differ
Binary files /home/amd/Prakash/llvm-3.2.org/utils/llvm-build/llvmbuild/__init__.pyc and llvm-3.2.src/utils/llvm-build/llvmbuild/__init__.pyc differ
Binary files /home/amd/Prakash/llvm-3.2.org/utils/llvm-build/llvmbuild/main.pyc and llvm-3.2.src/utils/llvm-build/llvmbuild/main.pyc differ
Binary files /home/amd/Prakash/llvm-3.2.org/utils/llvm-build/llvmbuild/util.pyc and llvm-3.2.src/utils/llvm-build/llvmbuild/util.pyc differ
Only in llvm-3.2.src/utils/TableGen: AMDBRIGLoweringEmitter.cpp
Only in llvm-3.2.src/utils/TableGen: AMDBRIGLoweringEmitter.h
Only in llvm-3.2.src/utils/TableGen: AMDDAGWalker.cpp
Only in llvm-3.2.src/utils/TableGen: AMDDAGWalker.h
Only in llvm-3.2.src/utils/TableGen: AMDHSAILVecMapEmiter.cpp
Only in llvm-3.2.src/utils/TableGen: AMDHSAILVecMapEmiter.h
diff -ur /home/amd/Prakash/llvm-3.2.org/utils/TableGen/AsmWriterEmitter.cpp llvm-3.2.src/utils/TableGen/AsmWriterEmitter.cpp
--- /home/amd/Prakash/llvm-3.2.org/utils/TableGen/AsmWriterEmitter.cpp	2012-10-26 02:03:17.000000000 +0530
+++ llvm-3.2.src/utils/TableGen/AsmWriterEmitter.cpp	2014-08-18 16:49:12.000000000 +0530
@@ -78,15 +78,18 @@
 
 /// EmitInstructions - Emit the last instruction in the vector and any other
 /// instructions that are suitably similar to it.
-static void EmitInstructions(std::vector<AsmWriterInst> &Insts,
+
+// This fix for a performance issue does not have any HSAIL dependencies.
+// However we want to be sure this change is properly marked.
+static void EmitInstructions(std::vector<AsmWriterInst*> &Insts,
                              raw_ostream &O) {
-  AsmWriterInst FirstInst = Insts.back();
+  AsmWriterInst &FirstInst = *Insts.back();
   Insts.pop_back();
 
   std::vector<AsmWriterInst> SimilarInsts;
   unsigned DifferingOperand = ~0;
   for (unsigned i = Insts.size(); i != 0; --i) {
-    unsigned DiffOp = Insts[i-1].MatchesAllButOneOp(FirstInst);
+    unsigned DiffOp = Insts[i-1]->MatchesAllButOneOp(FirstInst);
     if (DiffOp != ~1U) {
       if (DifferingOperand == ~0U)  // First match!
         DifferingOperand = DiffOp;
@@ -94,7 +97,7 @@
       // If this differs in the same operand as the rest of the instructions in
       // this class, move it to the SimilarInsts list.
       if (DifferingOperand == DiffOp || DiffOp == ~0U) {
-        SimilarInsts.push_back(Insts[i-1]);
+        SimilarInsts.push_back(*Insts[i-1]);
         Insts.erase(Insts.begin()+i-1);
       }
     }
@@ -440,7 +443,7 @@
   }
 
   // Emit the string itself.
-  O << "  const char AsmStrs[] = {\n";
+  O << "  static const char AsmStrs[] = {\n";
   StringTable.emit(O, printChar);
   O << "  };\n\n";
 
@@ -503,31 +506,26 @@
     BitsLeft -= NumBits;
   }
 
-  // Okay, delete instructions with no operand info left.
-  for (unsigned i = 0, e = Instructions.size(); i != e; ++i) {
-    // Entire instruction has been emitted?
-    AsmWriterInst &Inst = Instructions[i];
-    if (Inst.Operands.empty()) {
-      Instructions.erase(Instructions.begin()+i);
-      --i; --e;
+  // Create a reversed vector of pointers to the instructions, while filtering
+  // out those without operand info.
+  std::vector<AsmWriterInst*> InstPtrs;
+  for (std::vector<AsmWriterInst>::reverse_iterator it = Instructions.rbegin(); 
+  	   it != Instructions.rend(); ++it)
+  {
+    if (!it->Operands.empty()) {
+      InstPtrs.push_back(&(*it));
     }
   }
 
-
-  // Because this is a vector, we want to emit from the end.  Reverse all of the
-  // elements in the vector.
-  std::reverse(Instructions.begin(), Instructions.end());
-
-
   // Now that we've emitted all of the operand info that fit into 32 bits, emit
   // information for those instructions that are left.  This is a less dense
   // encoding, but we expect the main 32-bit table to handle the majority of
   // instructions.
-  if (!Instructions.empty()) {
+  if (!InstPtrs.empty()) {
     // Find the opcode # of inline asm.
     O << "  switch (MI->getOpcode()) {\n";
-    while (!Instructions.empty())
-      EmitInstructions(Instructions, O);
+    while (!InstPtrs.empty())
+      EmitInstructions(InstPtrs, O);
 
     O << "  }\n";
     O << "  return;\n";
diff -ur /home/amd/Prakash/llvm-3.2.org/utils/TableGen/CMakeLists.txt llvm-3.2.src/utils/TableGen/CMakeLists.txt
--- /home/amd/Prakash/llvm-3.2.org/utils/TableGen/CMakeLists.txt	2012-10-26 02:03:17.000000000 +0530
+++ llvm-3.2.src/utils/TableGen/CMakeLists.txt	2014-07-21 15:59:42.000000000 +0530
@@ -33,4 +33,7 @@
   X86DisassemblerTables.cpp
   X86ModRMFilters.cpp
   X86RecognizableInstr.cpp
+  AMDBRIGLoweringEmitter.cpp
+  AMDHSAILVecMapEmiter.cpp
+  AMDDAGWalker.cpp
   )
diff -ur /home/amd/Prakash/llvm-3.2.org/utils/TableGen/CodeGenInstruction.cpp llvm-3.2.src/utils/TableGen/CodeGenInstruction.cpp
--- /home/amd/Prakash/llvm-3.2.org/utils/TableGen/CodeGenInstruction.cpp	2012-10-26 02:03:17.000000000 +0530
+++ llvm-3.2.src/utils/TableGen/CodeGenInstruction.cpp	2014-08-18 16:48:03.000000000 +0530
@@ -328,6 +328,14 @@
   ImplicitDefs = R->getValueAsListOfDefs("Defs");
   ImplicitUses = R->getValueAsListOfDefs("Uses");
 
+  if( ( needSpecialProcessing = R->getValue("needSpecialProcessing") ) ) {
+    needSpecialProcessing = R->getValueAsBit("needSpecialProcessing");
+  }
+  if ((isImageInst = R->getValue("isImageInst")))
+    isImageInst = R->getValueAsBit("isImageInst");
+  if ((isCrossLaneInst = R->getValue("isCrossLaneInst")))
+    isCrossLaneInst = R->getValueAsBit("isCrossLaneInst");
+
   if (neverHasSideEffects + hasSideEffects > 1)
     PrintFatalError(R->getName() + ": multiple conflicting side-effect flags set!");
 
diff -ur /home/amd/Prakash/llvm-3.2.org/utils/TableGen/CodeGenInstruction.h llvm-3.2.src/utils/TableGen/CodeGenInstruction.h
--- /home/amd/Prakash/llvm-3.2.org/utils/TableGen/CodeGenInstruction.h	2012-10-26 02:03:17.000000000 +0530
+++ llvm-3.2.src/utils/TableGen/CodeGenInstruction.h	2014-08-18 16:49:38.000000000 +0530
@@ -270,6 +270,9 @@
     /// include text from the specified variant, returning the new string.
     static std::string FlattenAsmStringVariants(StringRef AsmString,
                                                 unsigned Variant);
+    bool needSpecialProcessing;
+    bool isImageInst;
+    bool isCrossLaneInst;
   };
 
 
diff -ur /home/amd/Prakash/llvm-3.2.org/utils/TableGen/TableGenBackends.h llvm-3.2.src/utils/TableGen/TableGenBackends.h
--- /home/amd/Prakash/llvm-3.2.org/utils/TableGen/TableGenBackends.h	2012-10-25 21:24:06.000000000 +0530
+++ llvm-3.2.src/utils/TableGen/TableGenBackends.h	2014-08-18 16:46:45.000000000 +0530
@@ -75,5 +75,7 @@
 void EmitRegisterInfo(RecordKeeper &RK, raw_ostream &OS);
 void EmitSubtarget(RecordKeeper &RK, raw_ostream &OS);
 void EmitMapTable(RecordKeeper &RK, raw_ostream &OS);
+void EmitBrigWriter(RecordKeeper &RK, raw_ostream &OS);
+void EmitHSAILVecMap(RecordKeeper &RK, raw_ostream &OS);
 
 } // End llvm namespace
diff -ur /home/amd/Prakash/llvm-3.2.org/utils/TableGen/TableGen.cpp llvm-3.2.src/utils/TableGen/TableGen.cpp
--- /home/amd/Prakash/llvm-3.2.org/utils/TableGen/TableGen.cpp	2012-10-04 02:59:19.000000000 +0530
+++ llvm-3.2.src/utils/TableGen/TableGen.cpp	2014-08-18 16:46:27.000000000 +0530
@@ -41,7 +41,9 @@
   GenTgtIntrinsic,
   GenEDInfo,
   PrintEnums,
-  PrintSets
+  PrintSets,
+  GenBrigWriter,
+  GenHSAILVecMap
 };
 
 namespace {
@@ -83,6 +85,10 @@
                                "Print enum values for a class"),
                     clEnumValN(PrintSets, "print-sets",
                                "Print expanded sets for testing DAG exprs"),
+                    clEnumValN(GenBrigWriter, "gen-brig-writer",
+                               "Generate BRIG writer"),
+                    clEnumValN(GenHSAILVecMap, "gen-hsail-vec-map",
+                               "Generate HSAIL scalar to vector map"),
                     clEnumValEnd));
 
   cl::opt<std::string>
@@ -162,6 +168,12 @@
     }
     break;
   }
+  case GenBrigWriter:
+    EmitBrigWriter(Records, OS);
+    break;
+  case GenHSAILVecMap:
+    EmitHSAILVecMap(Records,OS);
+    break;
   }
 
   return false;
